/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_1530();
// int __fastcall _cxa_finalize(void *);
// int __fastcall _cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
// int __fastcall _register_atfork(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// void free(void *ptr);
// int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...); weak
// int open(const char *file, int oflag, ...);
// void __fastcall _aeabi_memclr8(void *, size_t); idb
// int ioctl(int fd, unsigned int request, ...);
// void *calloc(size_t nmemb, size_t size);
// char *strdup(const char *s);
void __fastcall j_mixer_close(int *a1);
// int strcmp(const char *s1, const char *s2);
int __fastcall j_mixer_ctl_get_value(int **a1, unsigned int a2);
int __fastcall j_mixer_ctl_set_value(int **a1, unsigned int a2, int a3);
// void __fastcall _aeabi_memcpy(void *, const void *, size_t); idb
// int __fastcall _errno(_DWORD); weak
int __fastcall j_pcm_prepare(int a1);
// int __fastcall _vsnprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall _strlen_chk(_DWORD, _DWORD); weak
// char *strerror(int errnum);
int __fastcall j_pcm_start(int a1);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fprintf(FILE *stream, const char *format, ...);
// void __fastcall _aeabi_memclr4(void *, size_t); idb
// int sysconf(int name);
// int munmap(void *addr, size_t len);
int __fastcall j_pcm_stop(int a1);
// int fcntl(int fd, int cmd, ...);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
int __fastcall j_pcm_mmap_avail(int a1);
// int __fastcall _poll_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __fastcall j_pcm_state(int a1);
int __fastcall j_pcm_avail_update(int *a1);
int __fastcall j_pcm_mmap_commit(int *a1, int a2, int a3);
int __fastcall j_pcm_wait(int *a1, int a2);
int __fastcall j_pcm_mmap_transfer(int a1, int a2, unsigned int a3);
int __fastcall j_pcm_ioctl(int *a1, unsigned int a2, int a3);
// void abort(void);
// int __fastcall dladdr(_DWORD, _DWORD); weak
// int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD); weak
int j___aeabi_ldiv0();
// int raise(int sig);
int sub_1760();
int (*__fastcall sub_1780(int (*result)(void)))(void);
int __fastcall sub_17AC(void *a1);
int __fastcall sub_17F8(int a1, int a2, int a3);
void __fastcall mixer_close(int *a1);
int *__fastcall mixer_open(int a1);
int __fastcall mixer_get_name(int a1);
int __fastcall mixer_get_num_ctls(int a1);
int __fastcall mixer_get_ctl(int a1, unsigned int a2);
int __fastcall mixer_get_ctl_by_name(_DWORD *a1, char *s1);
int __fastcall mixer_ctl_update(int a1);
int __fastcall mixer_ctl_get_name(int a1);
unsigned int __fastcall mixer_ctl_get_type(int a1);
const char *__fastcall mixer_ctl_get_type_string(int a1);
int __fastcall mixer_ctl_get_num_values(int a1);
int __fastcall mixer_ctl_get_percent(int a1, unsigned int a2);
int __fastcall mixer_ctl_get_value(int **a1, unsigned int a2);
int __fastcall mixer_ctl_set_percent(int a1, unsigned int a2, int a3);
int __fastcall mixer_ctl_set_value(int **a1, unsigned int a2, int a3);
int __fastcall mixer_ctl_get_array(int a1, int *a2, size_t a3);
int __fastcall mixer_ctl_set_array(int a1, const void *a2, size_t a3);
int __fastcall mixer_ctl_get_range_min(int a1);
int __fastcall mixer_ctl_get_range_max(int a1);
int __fastcall mixer_ctl_get_num_enums(int a1);
int __fastcall mixer_ctl_get_enum_string(int a1, unsigned int a2);
int __fastcall mixer_ctl_set_enum_by_string(int a1, char *s1); // idb
int __fastcall pcm_get_buffer_size(int a1);
int __fastcall pcm_get_error(int a1);
int __fastcall pcm_format_to_bits(int a1);
unsigned int __fastcall pcm_bytes_to_frames(int a1, unsigned int a2);
int __fastcall pcm_frames_to_bytes(int a1, int a2);
int __fastcall pcm_get_htimestamp(int a1, int *a2, _QWORD *a3);
bool __fastcall pcm_is_ready(_DWORD *a1);
int __fastcall pcm_write(int a1, int a2, unsigned int a3);
int __fastcall pcm_prepare(int a1);
int sub_22EC(int a1, int a2, int a3, ...);
int __fastcall pcm_read(int a1, int a2, unsigned int a3);
int __fastcall pcm_start(int a1);
void *__fastcall pcm_params_get(int a1, int a2, int a3);
__int64 __fastcall sub_25B8(int a1);
void __fastcall pcm_params_free(void *a1);
int __fastcall pcm_params_get_mask(int a1, unsigned int a2);
int __fastcall pcm_params_get_min(int a1, unsigned int a2);
int __fastcall pcm_params_set_min(int result, unsigned int a2, int a3);
int __fastcall pcm_params_get_max(int a1, unsigned int a2);
int __fastcall pcm_params_set_max(int result, unsigned int a2, int a3);
unsigned int __fastcall pcm_params_to_string(int a1, int a2, unsigned int a3);
unsigned int __fastcall sub_28C0(_DWORD *a1, int a2, unsigned int a3, const char *a4, int a5, unsigned int a6);
int __fastcall pcm_params_format_test(int a1, int a2);
int __fastcall pcm_close(int a1);
int __fastcall pcm_stop(int a1);
void *__fastcall pcm_open(int a1, int a2, int a3, int *a4);
int __fastcall pcm_mmap_avail(int a1);
int __fastcall pcm_mmap_begin(int a1, _DWORD *a2, int *a3, unsigned int *a4);
int __fastcall pcm_mmap_commit(int *a1, int a2, int a3);
int __fastcall pcm_avail_update(int *a1);
int __fastcall pcm_state(int a1);
int __fastcall pcm_set_avail_min(int a1, Elf32_Dyn *a2);
int __fastcall pcm_wait(int *a1, int a2);
int __fastcall pcm_get_poll_fd(int a1);
int __fastcall pcm_mmap_transfer(int a1, int a2, unsigned int a3);
int __fastcall pcm_mmap_write(int a1, int a2, unsigned int a3);
int __fastcall pcm_mmap_read(int a1, int a2, unsigned int a3);
int __fastcall pcm_ioctl(int *a1, unsigned int a2, int a3);
int __fastcall pcm_get_trigger_tstamp(int *a1, _DWORD *a2);
int __fastcall pcm_get_xrun(int a1);
unsigned int *__fastcall sub_35B4(unsigned int *result, int *a2, int *a3);
int __fastcall sub_3608(int a1, int a2, unsigned int a3, unsigned int a4);
int __fastcall sub_38B8(int a1, int a2, unsigned int a3, int a4, _QWORD *a5);
int __fastcall sub_394C(int a1, int a2, unsigned int a3, int a4, int *a5);
int __fastcall sub_39E8(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_3B28(int a1, int a2, int a3);
int __fastcall sub_3B30(int a1, int a2);
int __fastcall sub_3B8C(int a1, int a2, int a3);
int __fastcall sub_3B94(int a1, int a2, int a3);
int __fastcall sub_3B9C(int *a1, int a2, int a3, int a4);
int __fastcall sub_3C48(const void *a1, int *a2, char a3);
void __fastcall __noreturn sub_3D38(int *a1, int a2, int a3, int a4);
void __fastcall __noreturn sub_3D6C(const char *a1, int a2, const char *a3);
int __fastcall sub_3DA0(int a1);
int __fastcall sub_3DDC(int a1);
int __fastcall sub_3E24(int a1, int a2);
int __fastcall sub_3E38(_DWORD *a1, int a2, int a3, int a4, int a5);
_QWORD *__fastcall sub_3E50(_QWORD *result);
_QWORD *__fastcall sub_3E58(_QWORD *result);
_QWORD *__fastcall sub_3E60(_QWORD *result);
void sub_3E68();
void sub_3EAC();
int __fastcall sub_3EC0(int a1, const void *a2);
int __fastcall sub_3F04(int a1, int a2, _DWORD *a3);
int __fastcall sub_3F32(int a1, int a2, int a3);
int __fastcall sub_3F76(int a1, int a2, _QWORD *a3);
int __fastcall sub_3FA6(int a1, int a2, int a3, int a4);
int __fastcall sub_3FDE(int a1);
int __fastcall sub_3FE4(int a1, int a2);
int __fastcall sub_4002(int a1);
int __fastcall sub_4014(int a1);
bool __fastcall sub_401A(int a1, int a2);
int __fastcall sub_403C(int a1, int a2);
int __fastcall sub_40C8(int result, int a2, int a3);
bool __fastcall sub_4154(int a1, int a2);
__int64 __fastcall sub_4174(int a1, int a2);
int __fastcall sub_4218(int a1, int a2, int a3, int a4);
bool __fastcall sub_42E4(_DWORD *a1);
_DWORD *__fastcall sub_4334(int a1, _DWORD *a2);
int __fastcall sub_434C(int a1);
int __fastcall sub_4362(int a1);
int __fastcall sub_4368(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_43D8(int *a1, int a2);
int __fastcall sub_444E(int result);
void __fastcall __noreturn sub_4458(const char *a1, const char *a2, int a3, const char *a4);
bool __fastcall sub_4484(int a1);
_DWORD *__fastcall sub_44D8(int a1);
int __fastcall sub_4530(int *a1, int a2, _DWORD *a3);
_DWORD *__fastcall sub_46D4(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, _DWORD *a8);
int __fastcall sub_4B60(int a1);
void sub_4B74();
void sub_4B7C();
void sub_4B84();
_DWORD *__fastcall sub_4B8C(int *a1);
_DWORD *__fastcall sub_4BD0(int *a1);
int _aeabi_ldiv0();
void __fastcall j_free(void *ptr); // idb
int __fastcall j_j_mixer_ctl_set_value(int **a1, unsigned int a2, int a3);
int __fastcall j_j_pcm_mmap_avail(int a1);
int __fastcall j_j_pcm_mmap_transfer(int a1, int a2, unsigned int a3);
int __fastcall sub_4CFC(int a1);
_DWORD *__fastcall sub_4D0C(int *a1);

//-------------------------------------------------------------------------
// Data declarations

char byte_4[] = { '\x01' }; // weak
Elf32_Dyn *off_BC[2] = { &stru_6E08, &stru_6E08 }; // weak
_UNKNOWN unk_4FD4; // weak
char asc_5BB8[2] = " "; // weak
_DWORD dword_5BC8[6] = { 10, 0, 6, 32, 0, 0 }; // weak
_DWORD dword_5BE0[16] = { 0, 1, 2, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0 }; // weak
_DWORD dword_5C20[5] = { -32, -5, -5, -86, -19 }; // weak
char *off_6CE0[36] =
{
  "BOOL",
  "INT",
  "ENUM",
  "BYTE",
  "IEC958",
  "INT64",
  "MMAP_INTERLEAVED",
  "MMAP_NONINTERLEAVED",
  "MMAP_COMPLEX",
  "RW_INTERLEAVED",
  "RW_NONINTERLEAVED",
  "S8",
  "U8",
  "S16_LE",
  "S16_BE",
  "U16_LE",
  "U16_BE",
  "S24_LE",
  "S24_BE",
  "U24_LE",
  "U24_BE",
  "S32_LE",
  "S32_BE",
  "U32_LE",
  "U32_BE",
  "FLOAT_LE",
  "FLOAT_BE",
  "FLOAT64_LE",
  "FLOAT64_BE",
  "IEC958_SUBFRAME_LE",
  "IEC958_SUBFRAME_BE",
  "MU_LAW",
  "A_LAW",
  "IMA_ADPCM",
  "MPEG",
  "GSM"
}; // weak
char *off_6CF8[30] =
{
  "MMAP_INTERLEAVED",
  "MMAP_NONINTERLEAVED",
  "MMAP_COMPLEX",
  "RW_INTERLEAVED",
  "RW_NONINTERLEAVED",
  "S8",
  "U8",
  "S16_LE",
  "S16_BE",
  "U16_LE",
  "U16_BE",
  "S24_LE",
  "S24_BE",
  "U24_LE",
  "U24_BE",
  "S32_LE",
  "S32_BE",
  "U32_LE",
  "U32_BE",
  "FLOAT_LE",
  "FLOAT_BE",
  "FLOAT64_LE",
  "FLOAT64_BE",
  "IEC958_SUBFRAME_LE",
  "IEC958_SUBFRAME_BE",
  "MU_LAW",
  "A_LAW",
  "IMA_ADPCM",
  "MPEG",
  "GSM"
}; // weak
char *off_6D0C[25] =
{
  "S8",
  "U8",
  "S16_LE",
  "S16_BE",
  "U16_LE",
  "U16_BE",
  "S24_LE",
  "S24_BE",
  "U24_LE",
  "U24_BE",
  "S32_LE",
  "S32_BE",
  "U32_LE",
  "U32_BE",
  "FLOAT_LE",
  "FLOAT_BE",
  "FLOAT64_LE",
  "FLOAT64_BE",
  "IEC958_SUBFRAME_LE",
  "IEC958_SUBFRAME_BE",
  "MU_LAW",
  "A_LAW",
  "IMA_ADPCM",
  "MPEG",
  "GSM"
}; // weak
char *off_6DBC = "STD"; // weak
void *off_6DC8 = (void *)0x3D35; // weak
void *off_7000 = &off_7000; // weak
_UNKNOWN unk_7004; // weak
_UNKNOWN unk_70DC; // weak
// extern _UNKNOWN _stack_chk_guard; weak
// extern struct _IO_FILE *stderr;


//----- (00001530) --------------------------------------------------------
void sub_1530()
{
  JUMPOUT(0);
}
// 153C: control flows out of bounds to 0

//----- (000015C8) --------------------------------------------------------
// attributes: thunk
void __fastcall j_mixer_close(int *a1)
{
  mixer_close(a1);
}

//----- (000015EC) --------------------------------------------------------
// attributes: thunk
int __fastcall j_mixer_ctl_get_value(int **a1, unsigned int a2)
{
  return mixer_ctl_get_value(a1, a2);
}

//----- (000015F8) --------------------------------------------------------
// attributes: thunk
int __fastcall j_mixer_ctl_set_value(int **a1, unsigned int a2, int a3)
{
  return mixer_ctl_set_value(a1, a2, a3);
}

//----- (0000161C) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_prepare(int a1)
{
  return pcm_prepare(a1);
}

//----- (0000164C) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_start(int a1)
{
  return pcm_start(a1);
}

//----- (00001694) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_stop(int a1)
{
  return pcm_stop(a1);
}

//----- (000016C4) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_mmap_avail(int a1)
{
  return pcm_mmap_avail(a1);
}

//----- (000016DC) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_state(int a1)
{
  return pcm_state(a1);
}

//----- (000016E8) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_avail_update(int *a1)
{
  return pcm_avail_update(a1);
}

//----- (000016F4) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_mmap_commit(int *a1, int a2, int a3)
{
  return pcm_mmap_commit(a1, a2, a3);
}

//----- (00001700) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_wait(int *a1, int a2)
{
  return pcm_wait(a1, a2);
}

//----- (0000170C) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_mmap_transfer(int a1, int a2, unsigned int a3)
{
  return pcm_mmap_transfer(a1, a2, a3);
}

//----- (00001718) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pcm_ioctl(int *a1, unsigned int a2, int a3)
{
  return pcm_ioctl(a1, a2, a3);
}

//----- (00001748) --------------------------------------------------------
// attributes: thunk
int j___aeabi_ldiv0()
{
  return _aeabi_ldiv0();
}

//----- (00001760) --------------------------------------------------------
int sub_1760()
{
  return _cxa_finalize(&off_7000);
}
// 7000: using guessed type void *off_7000;

//----- (00001780) --------------------------------------------------------
int (*__fastcall sub_1780(int (*result)(void)))(void)
{
  if ( result )
    return (int (*)(void))result();
  return result;
}

//----- (000017AC) --------------------------------------------------------
int __fastcall sub_17AC(void *a1)
{
  return _cxa_atexit((void (__fastcall *)(void *))sub_1780, a1, &off_7000);
}
// 7000: using guessed type void *off_7000;

//----- (000017F8) --------------------------------------------------------
int __fastcall sub_17F8(int a1, int a2, int a3)
{
  return _register_atfork(a1, a2, a3, &off_7000);
}
// 155C: using guessed type int __fastcall _register_atfork(_DWORD, _DWORD, _DWORD, _DWORD);
// 7000: using guessed type void *off_7000;

//----- (00001840) --------------------------------------------------------
void __fastcall mixer_close(int *a1)
{
  int v2; // r0
  char *v3; // r0
  unsigned int v4; // r1
  int v5; // r5
  char *v6; // r3
  void **v7; // r0
  void **v8; // r2
  int v9; // r7
  int i; // r4
  void *v11; // r0

  if ( a1 )
  {
    v2 = *a1;
    if ( *a1 >= 0 )
      close(v2);
    v3 = (char *)a1[96];
    if ( v3 )
    {
      v4 = a1[97];
      if ( v4 )
      {
        v5 = 0;
        while ( 1 )
        {
          v6 = &v3[12 * v5];
          v7 = (void **)(v6 + 8);
          v8 = (void **)*((_DWORD *)v6 + 2);
          if ( v8 )
          {
            v9 = *(_DWORD *)(*((_DWORD *)v6 + 1) + 80);
            if ( v9 )
            {
              free(*v8);
              v7 = (void **)(a1[96] + 12 * v5 + 8);
              if ( v9 != 1 )
              {
                for ( i = 1; i != v9; ++i )
                {
                  free(*((void **)*v7 + i));
                  v7 = (void **)(a1[96] + 12 * v5 + 8);
                }
              }
            }
            free(*v7);
            v4 = a1[97];
          }
          if ( ++v5 >= v4 )
            break;
          v3 = (char *)a1[96];
        }
        v3 = (char *)a1[96];
      }
      free(v3);
    }
    v11 = (void *)a1[95];
    if ( v11 )
      free(v11);
    j_free(a1);
  }
}

//----- (000018E8) --------------------------------------------------------
int *__fastcall mixer_open(int a1)
{
  int *v1; // r4
  int v2; // r5
  size_t v3; // r7
  void *v4; // r6
  void *v5; // r0
  int v6; // r6
  void *v7; // r0
  int v8; // r9
  int *v9; // r8
  _DWORD *v10; // r7
  _DWORD *v11; // r0
  _DWORD *v12; // r6
  int v13; // r10
  char *v14; // r0
  void *ptr; // [sp+8h] [bp-288h]
  char v17[256]; // [sp+10h] [bp-280h] BYREF
  int v18[68]; // [sp+110h] [bp-180h] BYREF
  int v19[18]; // [sp+220h] [bp-70h] BYREF

  v1 = 0;
  _snprintf_chk(v17, 256, 0, 256, "/dev/snd/controlC%u", a1);
  v2 = open(v17, 2);
  if ( v2 >= 0 )
  {
    memset(v19, 0, sizeof(v19));
    if ( ioctl(v2, 0xC0485510, v19) < 0 || (v1 = (int *)calloc(1u, 0x188u)) == 0 )
    {
      close(v2);
      return 0;
    }
    v3 = v19[3];
    v4 = calloc(v19[3], 0xCu);
    v1[96] = (int)v4;
    v5 = calloc(v3, 0x110u);
    v1[95] = (int)v5;
    if ( !v5 || !v4 || ioctl(v2, 0x81785501, v1 + 1) < 0 || (v6 = v19[3], (v7 = calloc(v19[3], 0x40u)) == 0) )
    {
LABEL_23:
      j_mixer_close(v1);
      return 0;
    }
    v19[1] = v6;
    v19[4] = (int)v7;
    ptr = v7;
    v1[97] = v6;
    *v1 = v2;
    if ( ioctl(v2, 0xC0485510, v19) < 0 )
    {
LABEL_22:
      free(ptr);
      goto LABEL_23;
    }
    if ( v1[97] )
    {
      v8 = 0;
      do
      {
        v9 = (int *)(v1[95] + 272 * v8);
        *v9 = *((_DWORD *)ptr + 16 * v8);
        if ( ioctl(v2, 0xC1105511, v9) < 0 )
          goto LABEL_22;
        *(_DWORD *)(v1[96] + 12 * v8 + 4) = v9;
        *(_DWORD *)(v1[96] + 12 * v8) = v1;
        if ( v9[16] == 3 )
        {
          v10 = v9 + 20;
          v11 = calloc(v9[20], 4u);
          v12 = v11;
          if ( !v11 )
            goto LABEL_22;
          *(_DWORD *)(v1[96] + 12 * v8 + 8) = v11;
          if ( *v10 )
          {
            v13 = 0;
            do
            {
              memset(v18, 0, sizeof(v18));
              v18[0] = *v9;
              v18[21] = v13;
              if ( ioctl(v2, 0xC1105511, v18) < 0 )
                goto LABEL_22;
              v14 = strdup((const char *)&v18[22]);
              v12[v13] = v14;
              if ( !v14 )
                goto LABEL_22;
            }
            while ( (unsigned int)++v13 < *v10 );
          }
        }
      }
      while ( ++v8 < (unsigned int)v1[97] );
    }
    free(ptr);
  }
  return v1;
}
// 1580: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (00001ADC) --------------------------------------------------------
int __fastcall mixer_get_name(int a1)
{
  return a1 + 44;
}

//----- (00001AE0) --------------------------------------------------------
int __fastcall mixer_get_num_ctls(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 388);
  else
    return 0;
}

//----- (00001AEC) --------------------------------------------------------
int __fastcall mixer_get_ctl(int a1, unsigned int a2)
{
  if ( a1 && *(_DWORD *)(a1 + 388) > a2 )
    return *(_DWORD *)(a1 + 384) + 12 * a2;
  else
    return 0;
}

//----- (00001B08) --------------------------------------------------------
int __fastcall mixer_get_ctl_by_name(_DWORD *a1, char *s1)
{
  unsigned int v2; // r7
  bool v4; // zf
  int v6; // r4
  unsigned int v7; // r5
  const char *i; // r6

  v4 = a1 == 0;
  if ( a1 )
  {
    v2 = a1[97];
    v4 = v2 == 0;
  }
  if ( v4 )
    return 0;
  v6 = 0;
  v7 = 0;
  for ( i = (const char *)(a1[95] + 16); strcmp(s1, i); i += 272 )
  {
    ++v7;
    v6 += 12;
    if ( v7 >= v2 )
      return 0;
  }
  return a1[96] + v6;
}
// 1B40: variable 'v2' is possibly undefined

//----- (00001B52) --------------------------------------------------------
int __fastcall mixer_ctl_update(int a1)
{
  return ioctl(**(_DWORD **)a1, 0xC1105511, *(_DWORD *)(a1 + 4));
}

//----- (00001B68) --------------------------------------------------------
int __fastcall mixer_ctl_get_name(int a1)
{
  if ( a1 )
    return *(_DWORD *)&byte_4[a1] + 16;
  else
    return 0;
}

//----- (00001B74) --------------------------------------------------------
unsigned int __fastcall mixer_ctl_get_type(int a1)
{
  unsigned int result; // r0

  if ( !a1 )
    return 6;
  result = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 64) - 1;
  if ( result >= 6 )
    return 6;
  return result;
}

//----- (00001B88) --------------------------------------------------------
const char *__fastcall mixer_ctl_get_type_string(int a1)
{
  unsigned int v1; // r0

  if ( !a1 )
    return (const char *)&unk_4FD4;
  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 64) - 1;
  if ( v1 > 5 )
    return "Unknown";
  else
    return off_6CE0[v1];
}
// 6CE0: using guessed type char *off_6CE0[36];

//----- (00001BB8) --------------------------------------------------------
int __fastcall mixer_ctl_get_num_values(int a1)
{
  if ( a1 )
    return *(_DWORD *)(*(_DWORD *)&byte_4[a1] + 72);
  else
    return 0;
}

//----- (00001BC4) --------------------------------------------------------
int __fastcall mixer_ctl_get_percent(int a1, unsigned int a2)
{
  int v2; // r4
  int value; // r0
  __int64 v4; // kr00_8

  if ( !a1 )
    return -22;
  v2 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(v2 + 64) != 2 )
    return -22;
  value = j_mixer_ctl_get_value((int **)a1, a2);
  v4 = *(_QWORD *)(v2 + 80);
  if ( HIDWORD(v4) == (_DWORD)v4 )
    return 0;
  else
    return 100 * ((value - (int)v4) / (HIDWORD(v4) - (int)v4));
}

//----- (00001BF4) --------------------------------------------------------
int __fastcall mixer_ctl_get_value(int **a1, unsigned int a2)
{
  int *v4; // r7
  int result; // r0
  int v6[178]; // [sp+0h] [bp-2E0h] BYREF

  if ( !a1 )
    return -22;
  v4 = a1[1];
  if ( v4[18] <= a2 )
    return -22;
  memset(v6, 0, sizeof(v6));
  v6[0] = *v4;
  result = ioctl(**a1, 0xC2C85512, v6);
  if ( result >= 0 )
  {
    switch ( a1[1][16] )
    {
      case 1:
        result = v6[a2 + 18] != 0;
        break;
      case 2:
      case 3:
        result = v6[a2 + 18];
        break;
      case 4:
        result = *((unsigned __int8 *)&v6[18] + a2);
        break;
      default:
        return -22;
    }
  }
  return result;
}

//----- (00001C90) --------------------------------------------------------
int __fastcall mixer_ctl_set_percent(int a1, unsigned int a2, int a3)
{
  _DWORD *v3; // r12
  int v4; // r3

  if ( !a1 )
    return -22;
  v3 = *(_DWORD **)(a1 + 4);
  if ( v3[16] != 2 )
    return -22;
  v4 = a3;
  if ( a3 < 0 )
    v4 = 0;
  if ( a3 > 100 )
    v4 = 100;
  return j_j_mixer_ctl_set_value((int **)a1, a2, (v3[21] - v3[20]) * v4 / 100 + v3[20]);
}

//----- (00001CDC) --------------------------------------------------------
int __fastcall mixer_ctl_set_value(int **a1, unsigned int a2, int a3)
{
  int *v6; // r7
  int result; // r0
  int v8[179]; // [sp+0h] [bp-2E8h] BYREF

  if ( !a1 )
    return -22;
  v6 = a1[1];
  if ( v6[18] <= a2 )
    return -22;
  memset(v8, 0, 0x2C8u);
  v8[0] = *v6;
  result = ioctl(**a1, 0xC2C85512, v8);
  if ( result >= 0 )
  {
    switch ( a1[1][16] )
    {
      case 1:
        v8[a2 + 18] = a3 != 0;
        break;
      case 2:
      case 3:
        v8[a2 + 18] = a3;
        break;
      case 4:
        *((_BYTE *)&v8[18] + a2) = a3;
        break;
      default:
        return -22;
    }
    return ioctl(**a1, 0xC2C85513, v8);
  }
  return result;
}

//----- (00001D90) --------------------------------------------------------
int __fastcall mixer_ctl_get_array(int a1, int *a2, size_t a3)
{
  bool v6; // zf
  int v7; // r6
  int v8; // r5
  int v9; // r0
  int v10; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r8
  int v14[178]; // [sp+0h] [bp-2E8h] BYREF

  if ( !a1 )
    return -22;
  v6 = a2 == 0;
  v7 = -22;
  if ( a2 )
    v6 = a3 == 0;
  if ( !v6 )
  {
    v8 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)(v8 + 72) >= a3 )
    {
      memset(v14, 0, sizeof(v14));
      v14[0] = *(_DWORD *)v8;
      v9 = *(_DWORD *)(v8 + 64);
      if ( (unsigned int)(v9 - 1) < 2 )
      {
        v7 = ioctl(**(_DWORD **)a1, 0xC2C85512, v14);
        if ( v7 >= 0 )
        {
          v10 = 4;
          goto LABEL_12;
        }
      }
      else
      {
        if ( v9 != 4 )
        {
          if ( v9 == 5 )
          {
            v10 = 176;
LABEL_12:
            qmemcpy(a2, &v14[18], v10 * a3);
            return 0;
          }
          return -22;
        }
        if ( (*(_BYTE *)(v8 + 68) & 0x30) == 0 )
        {
          v7 = ioctl(**(_DWORD **)a1, 0xC2C85512, v14);
          if ( v7 < 0 )
            return v7;
          v10 = 1;
          goto LABEL_12;
        }
        if ( a3 > 0xFFFFFFF7 )
          return -22;
        v12 = calloc(1u, a3 + 8);
        v13 = v12;
        if ( v12 )
        {
          *v12 = *(_DWORD *)v8;
          v12[1] = a3;
          v7 = ioctl(**(_DWORD **)a1, 0xC008551A, v12);
          qmemcpy(a2, v13 + 2, a3);
          free(v13);
        }
        else
        {
          return -12;
        }
      }
    }
  }
  return v7;
}

//----- (00001EB8) --------------------------------------------------------
int __fastcall mixer_ctl_set_array(int a1, const void *a2, size_t a3)
{
  bool v6; // zf
  int v7; // r7
  int v8; // r5
  int v9; // r0
  int v10; // r1
  _DWORD *v12; // r0
  void *v13; // r8
  int v14[178]; // [sp+0h] [bp-2E8h] BYREF

  if ( !a1 )
    return -22;
  v6 = a2 == 0;
  v7 = -22;
  if ( a2 )
    v6 = a3 == 0;
  if ( !v6 )
  {
    v8 = *(_DWORD *)(a1 + 4);
    if ( *(_DWORD *)(v8 + 72) >= a3 )
    {
      memset(v14, 0, sizeof(v14));
      v14[0] = *(_DWORD *)v8;
      v9 = *(_DWORD *)(v8 + 64);
      if ( (unsigned int)(v9 - 1) < 2 )
      {
        v10 = 4;
        goto LABEL_11;
      }
      if ( v9 != 4 )
      {
        if ( v9 == 5 )
        {
          v10 = 176;
LABEL_11:
          qmemcpy(&v14[18], a2, v10 * a3);
          return ioctl(**(_DWORD **)a1, 0xC2C85513, v14);
        }
        return -22;
      }
      if ( (*(_BYTE *)(v8 + 68) & 0x30) == 0 )
      {
        v10 = 1;
        goto LABEL_11;
      }
      if ( a3 > 0xFFFFFFF7 )
        return -22;
      v12 = calloc(1u, a3 + 8);
      v13 = v12;
      if ( v12 )
      {
        *v12 = *(_DWORD *)v8;
        v12[1] = a3;
        qmemcpy(v12 + 2, a2, a3);
        v7 = ioctl(**(_DWORD **)a1, 0xC008551B, v13);
        free(v13);
      }
      else
      {
        return -12;
      }
    }
  }
  return v7;
}

//----- (00001FC0) --------------------------------------------------------
int __fastcall mixer_ctl_get_range_min(int a1)
{
  int v1; // r0

  if ( a1 && (v1 = *(_DWORD *)(a1 + 4), *(_DWORD *)(v1 + 64) == 2) )
    return *(_DWORD *)(v1 + 80);
  else
    return -22;
}

//----- (00001FD4) --------------------------------------------------------
int __fastcall mixer_ctl_get_range_max(int a1)
{
  int v1; // r0

  if ( a1 && (v1 = *(_DWORD *)(a1 + 4), *(_DWORD *)(v1 + 64) == 2) )
    return *(_DWORD *)(v1 + 84);
  else
    return -22;
}

//----- (00001FE8) --------------------------------------------------------
int __fastcall mixer_ctl_get_num_enums(int a1)
{
  if ( a1 )
    return *(_DWORD *)(*(_DWORD *)&byte_4[a1] + 80);
  else
    return 0;
}

//----- (00001FF4) --------------------------------------------------------
int __fastcall mixer_ctl_get_enum_string(int a1, unsigned int a2)
{
  int v2; // r2

  if ( a1 && (v2 = *(_DWORD *)(a1 + 4), *(_DWORD *)(v2 + 64) == 3) && *(_DWORD *)(v2 + 80) > a2 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * a2);
  else
    return 0;
}

//----- (00002010) --------------------------------------------------------
int __fastcall mixer_ctl_set_enum_by_string(int a1, char *s1)
{
  int *v4; // r8
  unsigned int v5; // r6
  int v6; // r4
  int v7; // r7
  int v9; // r0
  int v10[178]; // [sp+0h] [bp-2E8h] BYREF

  if ( !a1 )
    return -22;
  v4 = *(int **)(a1 + 4);
  if ( v4[16] != 3 )
    return -22;
  v5 = v4[20];
  if ( !v5 )
    return -22;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = 0;
  while ( strcmp(s1, *(const char **)(v6 + 4 * v7)) )
  {
    if ( ++v7 >= v5 )
      return -22;
  }
  memset(v10, 0, sizeof(v10));
  v10[18] = v7;
  v10[0] = *v4;
  v9 = ioctl(**(_DWORD **)a1, 0xC2C85513, v10);
  return v9 & (v9 >> 31);
}

//----- (000020AC) --------------------------------------------------------
int __fastcall pcm_get_buffer_size(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (000020B0) --------------------------------------------------------
int __fastcall pcm_get_error(int a1)
{
  *(_BYTE *)(a1 + 151) = 0;
  return a1 + 24;
}

//----- (000020BC) --------------------------------------------------------
int __fastcall pcm_format_to_bits(int a1)
{
  unsigned int v1; // r0

  v1 = a1 - 1;
  if ( v1 <= 3 )
    return *(_DWORD *)&asc_5BB8[4 * v1];
  else
    return 16;
}

//----- (000020D4) --------------------------------------------------------
unsigned int __fastcall pcm_bytes_to_frames(int a1, unsigned int a2)
{
  int v2; // r2
  unsigned int v3; // r0
  int v4; // r0

  v2 = *(_DWORD *)(a1 + 152);
  v3 = *(_DWORD *)(a1 + 168) - 1;
  if ( v3 > 3 )
    v4 = 2;
  else
    v4 = *(_DWORD *)&asc_5BB8[4 * v3] >> 3;
  return a2 / (v4 * v2);
}

//----- (000020FC) --------------------------------------------------------
int __fastcall pcm_frames_to_bytes(int a1, int a2)
{
  int v2; // r3
  int v3; // r0
  int v4; // r1

  v2 = *(_DWORD *)(a1 + 168);
  v3 = *(_DWORD *)(a1 + 152) * a2;
  if ( (unsigned int)(v2 - 1) > 3 )
    v4 = 2;
  else
    v4 = *(_DWORD *)&asc_5BB8[4 * v2 - 4] >> 3;
  return v3 * v4;
}

//----- (00002124) --------------------------------------------------------
int __fastcall pcm_get_htimestamp(int a1, int *a2, _QWORD *a3)
{
  _DWORD *v6; // r0
  int v7; // r0
  bool v8; // zf
  __int64 v9; // r0
  __int64 v10; // kr00_8
  int v12; // r1
  int v13; // r2
  int v14; // r1
  int v15; // r0

  if ( !a1 )
    return -1;
  if ( *(int *)a1 < 0 )
    return -1;
  v6 = *(_DWORD **)(a1 + 200);
  if ( v6 )
  {
    *v6 = 3;
    if ( ioctl(*(_DWORD *)a1, 0xC0844123, *(_DWORD *)(a1 + 200)) < 0 )
      return -1;
  }
  v7 = *(_DWORD *)(a1 + 192);
  if ( !v7 )
    return -1;
  v8 = *(_DWORD *)v7 == 5;
  if ( *(_DWORD *)v7 != 5 )
    v8 = *(_DWORD *)v7 == 3;
  if ( !v8 )
    return -1;
  v10 = *(_QWORD *)(v7 + 12);
  LODWORD(v9) = *(_DWORD *)(v7 + 16);
  HIDWORD(v9) = v10;
  *a3 = __PAIR64__(v9, v10);
  if ( !v9 )
    return -1;
  v12 = *(_DWORD *)(*(_DWORD *)(a1 + 192) + 8);
  if ( (*(_BYTE *)(a1 + 7) & 0x10) == 0 )
    v12 += *(_DWORD *)(a1 + 16);
  v13 = *(_DWORD *)(a1 + 20);
  v14 = v12 - **(_DWORD **)(a1 + 196);
  if ( v14 <= -1 )
  {
    v15 = v13 + v14;
  }
  else
  {
    v15 = v14 - v13;
    if ( v14 <= v13 )
      v15 = v14;
  }
  *a2 = v15;
  return 0;
}

//----- (000021A4) --------------------------------------------------------
bool __fastcall pcm_is_ready(_DWORD *a1)
{
  return a1 && *a1 >= 0;
}

//----- (000021B4) --------------------------------------------------------
int __fastcall pcm_write(int a1, int a2, unsigned int a3)
{
  unsigned int v4; // r1
  int v5; // r1
  int result; // r0
  char v7; // r7
  int v8; // r0
  int *v9; // r0
  int v10; // r0
  int *v11; // r0
  char v12[4]; // [sp+4h] [bp-24h] BYREF
  int v13; // [sp+8h] [bp-20h]
  unsigned int v14; // [sp+Ch] [bp-1Ch]

  if ( (*(_BYTE *)(a1 + 7) & 0x10) != 0 )
    return -22;
  v13 = a2;
  v4 = *(_DWORD *)(a1 + 168) - 1;
  if ( v4 > 3 )
    v5 = 16;
  else
    v5 = *(_DWORD *)&asc_5BB8[4 * v4];
  v14 = a3 / ((unsigned int)(*(_DWORD *)(a1 + 152) * v5) >> 3);
  v7 = *(_BYTE *)(a1 + 8);
  while ( (v7 & 1) != 0 )
  {
    if ( !ioctl(*(_DWORD *)a1, 0x400C4150u, v12) )
      return 0;
    v8 = *(unsigned __int8 *)(a1 + 8);
    v7 = v8 & 0xFC;
    *(_BYTE *)(a1 + 8) = v8 & 0xFC;
    v9 = (int *)_errno(v8);
    if ( *v9 != 32 )
    {
      sub_22EC(a1, *v9, (int)"cannot write stream data");
      return -1;
    }
    ++*(_DWORD *)(a1 + 12);
    if ( (*(_BYTE *)(a1 + 4) & 4) != 0 )
      return -32;
  }
  result = j_pcm_prepare(a1);
  if ( result )
    return result;
  v10 = ioctl(*(_DWORD *)a1, 0x400C4150u, v12);
  if ( v10 )
  {
    v11 = (int *)_errno(v10);
    sub_22EC(a1, *v11, (int)"cannot write initial data");
    return -1;
  }
  *(_BYTE *)(a1 + 8) |= 1u;
  return 0;
}
// 1610: using guessed type int __fastcall _errno(_DWORD);
// 21B4: using guessed type char var_24[4];

//----- (000022A8) --------------------------------------------------------
int __fastcall pcm_prepare(int a1)
{
  int v2; // r0
  int *v4; // r0

  if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
    return 0;
  v2 = ioctl(*(_DWORD *)a1, 0x4140u);
  if ( v2 > -1 )
  {
    *(_BYTE *)(a1 + 8) |= 2u;
    return 0;
  }
  v4 = (int *)_errno(v2);
  sub_22EC(a1, *v4, (int)"cannot prepare channel");
  return -1;
}
// 1610: using guessed type int __fastcall _errno(_DWORD);

//----- (000022EC) --------------------------------------------------------
int sub_22EC(int a1, int a2, int a3, ...)
{
  int v4; // r6
  int v6; // r6
  char *v7; // r0
  int v9; // [sp+Ch] [bp-1Ch]
  va_list va; // [sp+24h] [bp-4h] BYREF

  va_start(va, a3);
  v4 = a1 + 24;
  _vsnprintf_chk(a1 + 24, 128, 0, -1, a3, (int *)va, (int *)va);
  v6 = _strlen_chk(v4, -1);
  if ( *(_DWORD *)_errno(v6) )
  {
    v7 = strerror(a2);
    _snprintf_chk(a1 + v6 + 24, 128 - v6, 0, -1, ": %s", v7);
  }
  *(_BYTE *)(a1 + 151) = 0;
  return _stack_chk_guard - v9;
}
// 2360: variable 'v9' is possibly undefined
// 1580: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1610: using guessed type int __fastcall _errno(_DWORD);
// 1628: using guessed type int __fastcall _vsnprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1634: using guessed type int __fastcall _strlen_chk(_DWORD, _DWORD);

//----- (00002380) --------------------------------------------------------
int __fastcall pcm_read(int a1, int a2, unsigned int a3)
{
  unsigned int v5; // r1
  int v6; // r1
  char v7; // r7
  int v8; // r0
  int *v9; // r0
  size_t v10; // r0
  char v11[4]; // [sp+4h] [bp-24h] BYREF
  int v12; // [sp+8h] [bp-20h]
  unsigned int v13; // [sp+Ch] [bp-1Ch]

  if ( (*(_BYTE *)(a1 + 7) & 0x10) == 0 )
    return -22;
  v12 = a2;
  v5 = *(_DWORD *)(a1 + 168) - 1;
  if ( v5 > 3 )
    v6 = 16;
  else
    v6 = *(_DWORD *)&asc_5BB8[4 * v5];
  v13 = a3 / ((unsigned int)(*(_DWORD *)(a1 + 152) * v6) >> 3);
  v7 = *(_BYTE *)(a1 + 8);
  while ( 1 )
  {
    if ( (v7 & 1) == 0 && j_pcm_start(a1) <= -1 )
    {
      v10 = fwrite("start error", 0xBu, 1u, stderr);
      return -*(_DWORD *)_errno(v10);
    }
    if ( !ioctl(*(_DWORD *)a1, 0x800C4151, v11) )
      break;
    v8 = *(unsigned __int8 *)(a1 + 8);
    v7 = v8 & 0xFC;
    *(_BYTE *)(a1 + 8) = v8 & 0xFC;
    v9 = (int *)_errno(v8);
    if ( *v9 != 32 )
    {
      sub_22EC(a1, *v9, (int)"cannot read stream data");
      return -1;
    }
    ++*(_DWORD *)(a1 + 12);
  }
  return 0;
}
// 1610: using guessed type int __fastcall _errno(_DWORD);
// 2380: using guessed type char var_24[4];

//----- (00002468) --------------------------------------------------------
int __fastcall pcm_start(int a1)
{
  int result; // r0
  _DWORD *v3; // r0
  bool v4; // zf
  int v5; // r0
  int *v6; // r0

  result = j_pcm_prepare(a1);
  if ( !result )
  {
    v3 = (_DWORD *)*(unsigned __int8 *)(a1 + 4);
    v4 = ((unsigned __int8)v3 & 1) == 0;
    if ( ((unsigned __int8)v3 & 1) != 0 )
    {
      v3 = *(_DWORD **)(a1 + 200);
      v4 = v3 == 0;
    }
    if ( !v4 )
    {
      *v3 = 0;
      ioctl(*(_DWORD *)a1, 0xC0844123, *(_DWORD *)(a1 + 200));
    }
    v5 = ioctl(*(_DWORD *)a1, 0x4142u);
    if ( v5 <= -1 )
    {
      v6 = (int *)_errno(v5);
      sub_22EC(a1, *v6, (int)"cannot start channel");
      return -1;
    }
    else
    {
      *(_BYTE *)(a1 + 8) |= 1u;
      return 0;
    }
  }
  return result;
}
// 1610: using guessed type int __fastcall _errno(_DWORD);

//----- (000024D0) --------------------------------------------------------
void *__fastcall pcm_params_get(int a1, int a2, int a3)
{
  int v3; // r3
  int v4; // r5
  void *v5; // r0
  void *v6; // r4
  FILE *v7; // r6
  _DWORD *v8; // r0
  char v10[256]; // [sp+14h] [bp-114h] BYREF

  v3 = 112;
  if ( (a3 & 0x10000000) != 0 )
    v3 = 99;
  _snprintf_chk(v10, 256, 0, 256, "/dev/snd/pcmC%uD%u%c", a1, a2, v3);
  v4 = open(v10, 2);
  if ( v4 <= -1 )
  {
    fprintf(stderr, "cannot open device '%s'\n", v10);
    return 0;
  }
  v5 = calloc(1u, 0x25Cu);
  v6 = v5;
  if ( !v5 )
  {
LABEL_9:
    close(v4);
    return 0;
  }
  sub_25B8((int)v5);
  if ( ioctl(v4, 0xC25C4110, v6) )
  {
    v7 = stderr;
    v8 = (_DWORD *)_errno(&stderr);
    fprintf(v7, "SNDRV_PCM_IOCTL_HW_REFINE error (%d)\n", *v8);
    free(v6);
    goto LABEL_9;
  }
  close(v4);
  return v6;
}
// 1580: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1610: using guessed type int __fastcall _errno(_DWORD);

//----- (000025B8) --------------------------------------------------------
__int64 __fastcall sub_25B8(int a1)
{
  int i; // r0
  int v3; // r2
  int j; // r2
  int v5; // r3
  __int64 result; // r0

  memset((void *)a1, 0, 0x25Cu);
  for ( i = 0; i != 96; i += 32 )
  {
    v3 = a1 + i;
    *(_DWORD *)(v3 + 4) = -1;
    *(_DWORD *)(v3 + 8) = -1;
  }
  for ( j = 0; j != 144; j += 12 )
  {
    v5 = a1 + j;
    *(_QWORD *)(v5 + 260) = 0xFFFFFFFF00000000LL;
  }
  result = 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 512) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 520) = -1;
  return result;
}

//----- (000025FA) --------------------------------------------------------
void __fastcall pcm_params_free(void *a1)
{
  if ( a1 )
    j_free(a1);
}
// 2602: conditional instruction was optimized away because r0.4==0

//----- (00002608) --------------------------------------------------------
int __fastcall pcm_params_get_mask(int a1, unsigned int a2)
{
  int result; // r0

  result = 0;
  if ( a2 <= 2 )
  {
    if ( a1 )
      return a1 + 32 * dword_5BE0[a2] + 4;
  }
  return result;
}
// 5BE0: using guessed type _DWORD dword_5BE0[16];

//----- (00002628) --------------------------------------------------------
int __fastcall pcm_params_get_min(int a1, unsigned int a2)
{
  int result; // r0
  unsigned int v4; // r0

  result = 0;
  if ( a1 && a2 <= 0xE )
  {
    v4 = dword_5BE0[a2] - 8;
    if ( v4 <= 0xB )
      return *(_DWORD *)(a1 + 12 * v4 + 260);
    else
      return 0;
  }
  return result;
}
// 5BE0: using guessed type _DWORD dword_5BE0[16];

//----- (0000265C) --------------------------------------------------------
int __fastcall pcm_params_set_min(int result, unsigned int a2, int a3)
{
  unsigned int v3; // r1

  if ( result && a2 <= 0xE )
  {
    v3 = dword_5BE0[a2] - 8;
    if ( v3 <= 0xB )
    {
      result += 12 * v3;
      *(_DWORD *)(result + 260) = a3;
    }
  }
  return result;
}
// 5BE0: using guessed type _DWORD dword_5BE0[16];

//----- (00002684) --------------------------------------------------------
int __fastcall pcm_params_get_max(int a1, unsigned int a2)
{
  int result; // r0
  unsigned int v4; // r0

  result = 0;
  if ( a1 && a2 <= 0xE )
  {
    v4 = dword_5BE0[a2] - 8;
    if ( v4 <= 0xB )
      return *(_DWORD *)(a1 + 12 * v4 + 264);
    else
      return 0;
  }
  return result;
}
// 5BE0: using guessed type _DWORD dword_5BE0[16];

//----- (000026B8) --------------------------------------------------------
int __fastcall pcm_params_set_max(int result, unsigned int a2, int a3)
{
  unsigned int v3; // r1

  if ( result && a2 <= 0xE )
  {
    v3 = dword_5BE0[a2] - 8;
    if ( v3 <= 0xB )
    {
      result += 12 * v3;
      *(_DWORD *)(result + 264) = a3;
    }
  }
  return result;
}
// 5BE0: using guessed type _DWORD dword_5BE0[16];

//----- (000026E0) --------------------------------------------------------
unsigned int __fastcall pcm_params_to_string(int a1, int a2, unsigned int a3)
{
  _DWORD *v6; // r5
  unsigned int v7; // r7
  unsigned int v8; // r0
  unsigned int v9; // r5
  unsigned int v10; // r0
  int v11; // r1
  unsigned int v12; // r2
  _DWORD *v13; // r0
  unsigned int v14; // r7
  __int64 v15; // r0
  int v16; // r5
  int v17; // r0
  int v18; // r0
  unsigned int v19; // r1
  int v20; // r5
  int v21; // r0
  int v22; // r0
  unsigned int v23; // r1
  int v24; // r5
  int v25; // r0
  int v26; // r0
  unsigned int v27; // r1
  int v28; // r5
  int v29; // r0
  int v30; // r0
  unsigned int v31; // r1
  int v32; // r0
  int v34; // [sp+4h] [bp-24h]
  int v35; // [sp+4h] [bp-24h]
  int v36; // [sp+4h] [bp-24h]
  int v37; // [sp+8h] [bp-20h]

  if ( a1 )
  {
    v6 = (_DWORD *)(a1 + 36);
    v7 = sub_28C0((_DWORD *)(a1 + 4), a2, a3, "Access", (int)off_6CF8, 5u);
  }
  else
  {
    v6 = 0;
    v7 = sub_28C0(0, a2, a3, "Access", (int)off_6CF8, 5u);
  }
  v8 = v7;
  if ( v7 > a3 )
    v8 = a3;
  v9 = sub_28C0(v6, a2 + v8, a3 - v8, "Format", (int)off_6D0C, 0x2Cu) + v7;
  v10 = v9;
  if ( v9 > a3 )
    v10 = a3;
  v11 = a2 + v10;
  v12 = a3 - v10;
  v13 = (_DWORD *)a1;
  if ( a1 )
    v13 = (_DWORD *)(a1 + 68);
  v14 = v9 + sub_28C0(v13, v11, v12, "Subformat", (int)&off_6DBC, 1u);
  if ( a1 )
    v15 = *(_QWORD *)(a1 + 296);
  else
    v15 = 0LL;
  v16 = 0;
  v37 = HIDWORD(v15);
  HIDWORD(v15) = v14;
  if ( v14 > a3 )
    HIDWORD(v15) = a3;
  v17 = _snprintf_chk(
          a2 + HIDWORD(v15),
          a3 - HIDWORD(v15),
          0,
          -1,
          "        Rate:\tmin=%uHz\tmax=%uHz\n",
          (_DWORD)v15,
          v37);
  if ( v17 > 0 )
    v14 += v17;
  v18 = 0;
  if ( a1 )
  {
    v18 = *(_DWORD *)(a1 + 288);
    v16 = *(_DWORD *)(a1 + 284);
  }
  v34 = v16;
  v19 = v14;
  if ( v14 > a3 )
    v19 = a3;
  v20 = 0;
  v21 = _snprintf_chk(a2 + v19, a3 - v19, 0, -1, "    Channels:\tmin=%u\t\tmax=%u\n", v34, v18);
  if ( v21 > 0 )
    v14 += v21;
  v22 = 0;
  if ( a1 )
  {
    v22 = *(_DWORD *)(a1 + 264);
    v20 = *(_DWORD *)(a1 + 260);
  }
  v35 = v20;
  v23 = v14;
  if ( v14 > a3 )
    v23 = a3;
  v24 = 0;
  v25 = _snprintf_chk(a2 + v23, a3 - v23, 0, -1, " Sample bits:\tmin=%u\t\tmax=%u\n", v35, v22);
  if ( v25 > 0 )
    v14 += v25;
  v26 = 0;
  if ( a1 )
  {
    v26 = *(_DWORD *)(a1 + 324);
    v24 = *(_DWORD *)(a1 + 320);
  }
  v36 = v24;
  v27 = v14;
  if ( v14 > a3 )
    v27 = a3;
  v28 = 0;
  v29 = _snprintf_chk(a2 + v27, a3 - v27, 0, -1, " Period size:\tmin=%u\t\tmax=%u\n", v36, v26);
  if ( v29 > 0 )
    v14 += v29;
  v30 = 0;
  if ( a1 )
  {
    v30 = *(_DWORD *)(a1 + 348);
    v28 = *(_DWORD *)(a1 + 344);
  }
  v31 = v14;
  if ( v14 > a3 )
    v31 = a3;
  v32 = _snprintf_chk(a2 + v31, a3 - v31, 0, -1, "Period count:\tmin=%u\t\tmax=%u\n", v28, v30);
  if ( v32 > 0 )
    v14 += v32;
  return v14;
}
// 1580: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 6CF8: using guessed type char *off_6CF8[30];
// 6D0C: using guessed type char *off_6D0C[25];
// 6DBC: using guessed type char *off_6DBC;

//----- (000028C0) --------------------------------------------------------
unsigned int __fastcall sub_28C0(_DWORD *a1, int a2, unsigned int a3, const char *a4, int a5, unsigned int a6)
{
  unsigned int v10; // r6
  int v11; // r10
  unsigned int v12; // r7
  int v13; // r0
  unsigned int v14; // r5
  int v15; // r10
  unsigned int v16; // r1
  int v17; // r0
  unsigned int v18; // r1
  int v19; // r0

  if ( !a1 )
    return 0;
  v11 = a5;
  v10 = a6;
  if ( a6 < 0x20 )
  {
    v12 = 0;
    v13 = _snprintf_chk(a2, a3, 0, -1, "%12s:\t%#08x\n", a4, *a1);
    if ( v13 > 0 )
      v12 = v13;
LABEL_14:
    v10 = a6;
    if ( !a6 )
      return v12;
    v11 = a5;
    v14 = 0;
    goto LABEL_16;
  }
  v14 = 0;
  v12 = 0;
  if ( (a6 + 31) >> 5 )
  {
    v15 = 0;
    v12 = 0;
    do
    {
      v16 = v12;
      if ( v12 > a3 )
        v16 = a3;
      v17 = _snprintf_chk(a2 + v16, a3 - v16, 0, -1, "%9s[%d]:\t%#08x\n", a4, v15, a1[v15]);
      ++v15;
      if ( v17 > 0 )
        v12 += v17;
    }
    while ( (a6 + 31) >> 5 != v15 );
    goto LABEL_14;
  }
  do
  {
LABEL_16:
    if ( v14 <= 0xFF && (a1[v14 >> 5] & (1 << (v14 & 0x1F))) != 0 )
    {
      v18 = v12;
      if ( v12 > a3 )
        v18 = a3;
      v19 = _snprintf_chk(a2 + v18, a3 - v18, 0, -1, "%12s \t%s\n", &unk_4FD4, *(_DWORD *)(v11 + 4 * v14));
      if ( v19 > 0 )
        v12 += v19;
    }
    ++v14;
  }
  while ( v10 != v14 );
  return v12;
}
// 1580: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (000029C8) --------------------------------------------------------
int __fastcall pcm_params_format_test(int a1, int a2)
{
  unsigned int v2; // r3
  bool v3; // r1
  int v4; // r12
  _DWORD *v5; // r1

  if ( (unsigned int)(a2 - 1) > 3 )
    v2 = 2;
  else
    v2 = dword_5BC8[a2 - 1];
  v3 = a2 != 0;
  v4 = 0;
  if ( v2 <= 0xFF && (!v3 || v2 != 2) )
  {
    v5 = (_DWORD *)((v2 >> 3) & 0x1FFFFFFC);
    if ( a1 )
      v5 = (_DWORD *)(a1 + 4 * (v2 >> 5) + 36);
    return (*v5 >> (v2 & 0x1F)) & 1;
  }
  return v4;
}
// 5BC8: using guessed type _DWORD dword_5BC8[6];

//----- (00002A24) --------------------------------------------------------
int __fastcall pcm_close(int a1)
{
  void *v2; // r0
  _DWORD *v3; // r7
  _DWORD *v4; // r6
  int v5; // r5
  void *v6; // r0
  void *v7; // r0
  unsigned int v8; // r2
  int v9; // r2

  if ( (_UNKNOWN *)a1 != &unk_7004 )
  {
    v2 = *(void **)(a1 + 200);
    if ( v2 )
    {
      free(v2);
      v3 = (_DWORD *)(a1 + 196);
      *(_DWORD *)(a1 + 200) = 0;
      v4 = (_DWORD *)(a1 + 192);
    }
    else
    {
      v5 = sysconf(40);
      v4 = (_DWORD *)(a1 + 192);
      v6 = *(void **)(a1 + 192);
      if ( v6 )
        munmap(v6, v5);
      v3 = (_DWORD *)(a1 + 196);
      v7 = *(void **)(a1 + 196);
      if ( v7 )
        munmap(v7, v5);
    }
    *v4 = 0;
    *v3 = 0;
    if ( (*(_BYTE *)(a1 + 4) & 1) != 0 )
    {
      j_pcm_stop(a1);
      v8 = *(_DWORD *)(a1 + 168) - 1;
      if ( v8 > 3 )
        v9 = 2;
      else
        v9 = *(_DWORD *)&asc_5BB8[4 * v8] >> 3;
      munmap(*(void **)(a1 + 204), *(_DWORD *)(a1 + 16) * *(_DWORD *)(a1 + 152) * v9);
    }
    if ( *(int *)a1 >= 0 )
      close(*(_DWORD *)a1);
    free((void *)a1);
  }
  return 0;
}

//----- (00002ACC) --------------------------------------------------------
int __fastcall pcm_stop(int a1)
{
  int v2; // r0
  int *v4; // r0

  v2 = ioctl(*(_DWORD *)a1, 0x4143u);
  if ( v2 <= -1 )
  {
    v4 = (int *)_errno(v2);
    sub_22EC(a1, *v4, (int)"cannot stop channel");
    return -1;
  }
  else
  {
    *(_BYTE *)(a1 + 8) &= 0xFCu;
    return 0;
  }
}
// 1610: using guessed type int __fastcall _errno(_DWORD);

//----- (00002B08) --------------------------------------------------------
void *__fastcall pcm_open(int a1, int a2, int a3, int *a4)
{
  void *v8; // r8
  bool v9; // zf
  void *result; // r0
  int v11; // r3
  int v12; // r5
  int v13; // r6
  int v14; // r7
  int v15; // r3
  int v16; // r5
  int v17; // r6
  int v18; // r7
  int v19; // r0
  int v20; // r0
  int v21; // r4
  int v22; // r0
  int v23; // r0
  int v24; // r0
  int *v25; // r0
  int *v26; // r0
  const char *v27; // r2
  unsigned int v28; // r0
  unsigned int v29; // r1
  int v30; // r0
  int v31; // r1
  unsigned int v32; // r0
  int v33; // r0
  int v34; // r0
  int *v35; // r0
  int v36; // r0
  int v37; // r1
  int v38; // r0
  int v39; // r0
  unsigned int v40; // r1
  int v41; // r1
  void *v42; // r0
  unsigned int v43; // r0
  int v44; // r1
  unsigned int v45; // r2
  int v46; // r2
  int v47; // r0
  int v48; // r0
  unsigned int v49; // r0
  unsigned int v50; // r1
  unsigned int v51; // r2
  int v52; // r0
  int v53; // r1
  unsigned int v54; // r2
  int v55; // r2
  int v56; // r5
  void *v57; // r0
  _DWORD *v58; // r0
  _DWORD *v59; // r0
  int v60; // r1
  int v61; // r1
  int v62; // r1
  int v63; // [sp+14h] [bp-514h] BYREF
  char v64[256]; // [sp+18h] [bp-510h] BYREF
  int v65[27]; // [sp+118h] [bp-410h] BYREF
  int v66[9]; // [sp+184h] [bp-3A4h] BYREF
  int v67[58]; // [sp+1A8h] [bp-380h]
  char v68; // [sp+290h] [bp-298h]
  int v69; // [sp+294h] [bp-294h]
  int v70; // [sp+298h] [bp-290h]
  char v71; // [sp+29Ch] [bp-28Ch]
  int v72; // [sp+2A0h] [bp-288h]
  int v73; // [sp+2A4h] [bp-284h]
  char v74; // [sp+2A8h] [bp-280h]
  unsigned int v75; // [sp+2ACh] [bp-27Ch]
  unsigned int v76; // [sp+2B0h] [bp-278h]
  char v77; // [sp+2B4h] [bp-274h]
  int v78; // [sp+2C4h] [bp-264h]
  int v79; // [sp+2C8h] [bp-260h]
  unsigned __int8 v80; // [sp+2CCh] [bp-25Ch]
  int v81; // [sp+2DCh] [bp-24Ch]
  int v82; // [sp+2E0h] [bp-248h]
  unsigned __int8 v83; // [sp+2E4h] [bp-244h]
  char v84[288]; // [sp+3E0h] [bp-148h] BYREF

  v8 = calloc(1u, 0xD8u);
  v9 = a4 == 0;
  result = &unk_7004;
  if ( a4 )
    v9 = v8 == 0;
  if ( !v9 )
  {
    v11 = a4[1];
    v12 = a4[2];
    v13 = a4[3];
    v14 = a4[4];
    *((_DWORD *)v8 + 38) = *a4;
    *((_DWORD *)v8 + 39) = v11;
    *((_DWORD *)v8 + 40) = v12;
    *((_DWORD *)v8 + 41) = v13;
    *((_DWORD *)v8 + 42) = v14;
    v15 = a4[6];
    v16 = a4[7];
    v17 = a4[8];
    v18 = a4[9];
    *((_DWORD *)v8 + 43) = a4[5];
    *((_DWORD *)v8 + 44) = v15;
    *((_DWORD *)v8 + 45) = v16;
    *((_DWORD *)v8 + 46) = v17;
    *((_DWORD *)v8 + 47) = v18;
    v19 = 112;
    if ( (a3 & 0x10000000) != 0 )
      v19 = 99;
    _snprintf_chk(v64, 256, 0, 256, "/dev/snd/pcmC%uD%u%c", a1, a2, v19);
    *((_DWORD *)v8 + 1) = a3;
    v20 = open(v64, 2050);
    v21 = v20;
    *(_DWORD *)v8 = v20;
    if ( v20 <= -1 )
    {
      v26 = (int *)_errno(v20);
      v27 = "cannot open device '%s'";
    }
    else
    {
      v22 = fcntl(v20, 3);
      v23 = fcntl(v21, 4, v22 & 0xFFFFF7FF);
      if ( v23 > -1 )
      {
        v24 = ioctl(*(_DWORD *)v8, 0x81204101, v84);
        if ( v24 )
        {
          v25 = (int *)_errno(v24);
          sub_22EC((int)v8, *v25, (int)"cannot get info");
LABEL_27:
          if ( *(int *)v8 >= 0 )
            close(*(_DWORD *)v8);
          free(v8);
          return &unk_7004;
        }
        sub_25B8((int)v66);
        v28 = a4[4] - 1;
        if ( v28 > 3 )
          v29 = 2;
        else
          v29 = dword_5BC8[v28];
        v67[0] = 0;
        v67[1] = 0;
        v67[v29 >> 5] |= 1 << (v29 & 0x1F);
        v67[8] = 1;
        v67[9] = 0;
        v78 = a4[2];
        if ( v28 > 3 )
          v30 = 16;
        else
          v30 = *(_DWORD *)&asc_5BB8[4 * v28];
        v67[56] = v30;
        v67[57] = v30;
        v68 |= 4u;
        v31 = *a4;
        v69 = *a4 * v30;
        v70 = v69;
        v71 |= 4u;
        v72 = v31;
        v73 = v31;
        v74 |= 4u;
        v81 = a4[3];
        v82 = v81;
        v83 |= 4u;
        v32 = a4[1];
        v75 = v32;
        v76 = v32;
        v77 |= 4u;
        if ( (a3 & 2) != 0 )
        {
          if ( (a3 & 1) == 0 )
          {
            sub_22EC((int)v8, -22, (int)"noirq only currently supported with mmap().");
            goto LABEL_27;
          }
          v66[0] |= 4u;
          *((_DWORD *)v8 + 52) = v32 / 0x3E8;
        }
        v66[2] = 0;
        v33 = 8;
        if ( (a3 & 1) != 0 )
          v33 = 1;
        v66[1] = v33;
        v34 = ioctl(*(_DWORD *)v8, 0xC25C4111, v66);
        if ( v34 )
        {
          v35 = (int *)_errno(v34);
          sub_22EC((int)v8, *v35, (int)"cannot set hw params");
          goto LABEL_27;
        }
        v36 = v79 & (v80 << 29 >> 31);
        a4[2] = v36;
        v37 = v82 & (v83 << 29 >> 31);
        a4[3] = v37;
        v38 = v37 * v36;
        *((_DWORD *)v8 + 4) = v38;
        if ( (a3 & 1) != 0 )
        {
          v39 = v38 * *((_DWORD *)v8 + 38);
          v40 = *((_DWORD *)v8 + 42) - 1;
          v41 = v40 > 3 ? 2 : *(_DWORD *)&asc_5BB8[4 * v40] >> 3;
          v42 = mmap(0, v41 * v39, 3, 1, *(_DWORD *)v8, 0);
          *((_DWORD *)v8 + 51) = v42;
          if ( v42 == (void *)-1 )
          {
            v44 = -*(_DWORD *)_errno(-1);
            v45 = *((_DWORD *)v8 + 42) - 1;
            if ( v45 > 3 )
              v46 = 2;
            else
              v46 = *(_DWORD *)&asc_5BB8[4 * v45] >> 3;
            sub_22EC(
              (int)v8,
              v44,
              (int)"failed to mmap buffer %d bytes\n",
              *((_DWORD *)v8 + 4) * *((_DWORD *)v8 + 38) * v46);
            goto LABEL_27;
          }
        }
        memset(v65, 0, 0x68u);
        v65[0] = 1;
        v65[1] = 1;
        if ( a4[5] )
        {
          v65[5] = a4[5];
        }
        else
        {
          if ( (*((_BYTE *)v8 + 7) & 0x10) != 0 )
            v43 = 1;
          else
            v43 = (unsigned int)(a4[2] * a4[3]) >> 1;
          v65[5] = v43;
          *((_DWORD *)v8 + 43) = v43;
        }
        if ( a4[6] )
        {
          v65[6] = a4[6];
        }
        else
        {
          v47 = a4[2] * a4[3];
          if ( (*((_BYTE *)v8 + 7) & 0x10) != 0 )
            v47 *= 10;
          v65[6] = v47;
          *((_DWORD *)v8 + 44) = v47;
        }
        if ( *((_DWORD *)v8 + 47) )
        {
          v65[3] = a4[9];
        }
        else
        {
          if ( (*((_BYTE *)v8 + 4) & 1) != 0 )
            v48 = *((_DWORD *)v8 + 40);
          else
            v48 = 1;
          v65[3] = v48;
          *((_DWORD *)v8 + 47) = v48;
        }
        v65[4] = (unsigned int)a4[2] >> 1;
        v65[7] = a4[7];
        v65[8] = a4[8];
        v49 = *((_DWORD *)v8 + 4);
        v65[9] = v49;
        v50 = 0x7FFFFFFF - v49;
        do
        {
          v51 = v49;
          v49 *= 2;
        }
        while ( v49 <= v50 );
        *((_DWORD *)v8 + 5) = v51;
        v52 = ioctl(*(_DWORD *)v8, 0xC0684113, v65);
        if ( v52 )
        {
          v53 = *(_DWORD *)_errno(v52);
          sub_22EC((int)v8, v53, (int)"cannot set sw params");
LABEL_60:
          if ( (a3 & 1) != 0 )
          {
            v54 = *((_DWORD *)v8 + 42) - 1;
            if ( v54 > 3 )
              v55 = 2;
            else
              v55 = *(_DWORD *)&asc_5BB8[4 * v54] >> 3;
            munmap(*((void **)v8 + 51), *((_DWORD *)v8 + 4) * *((_DWORD *)v8 + 38) * v55);
          }
          goto LABEL_27;
        }
        if ( !*((_DWORD *)v8 + 50) )
        {
          v56 = sysconf(40);
          v57 = mmap(0, v56, 1, 1, *(_DWORD *)v8, 0x80000000);
          *((_DWORD *)v8 + 48) = v57;
          if ( v57 )
          {
            if ( v57 == (void *)-1 )
            {
              *((_DWORD *)v8 + 48) = 0;
            }
            else
            {
              v58 = mmap(0, v56, 3, 1, *(_DWORD *)v8, -2130706432);
              *((_DWORD *)v8 + 49) = v58;
              if ( v58 )
              {
                if ( v58 != (_DWORD *)-1 )
                {
                  if ( (*((_BYTE *)v8 + 4) & 1) != 0 )
                    v61 = *((_DWORD *)v8 + 47);
                  else
                    v61 = 1;
                  v58[1] = v61;
                  goto LABEL_85;
                }
                *((_DWORD *)v8 + 49) = 0;
              }
              munmap(*((void **)v8 + 48), v56);
              *((_DWORD *)v8 + 48) = 0;
            }
          }
          v59 = calloc(1u, 0x84u);
          *((_DWORD *)v8 + 50) = v59;
          if ( !v59 )
          {
            sub_22EC((int)v8, -12, (int)"mmap status failed");
            goto LABEL_60;
          }
          *((_DWORD *)v8 + 48) = v59 + 1;
          *((_DWORD *)v8 + 49) = v59 + 17;
          if ( (*((_BYTE *)v8 + 4) & 1) != 0 )
            v60 = *((_DWORD *)v8 + 47);
          else
            v60 = 1;
          v59[18] = v60;
          ioctl(*(_DWORD *)v8, 0xC0844123, *((_DWORD *)v8 + 50));
        }
LABEL_85:
        if ( (*((_BYTE *)v8 + 4) & 8) == 0 || (v63 = 1, v62 = ioctl(*(_DWORD *)v8, 0x40044103u, &v63), v62 >= 0) )
        {
          *((_DWORD *)v8 + 3) = 0;
          return v8;
        }
        sub_22EC((int)v8, v62, (int)"cannot set timestamp type");
        goto LABEL_60;
      }
      v26 = (int *)_errno(v23);
      v27 = "failed to reset blocking mode '%s'";
    }
    sub_22EC((int)v8, *v26, (int)v27, v64);
    goto LABEL_27;
  }
  return result;
}
// 1580: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1610: using guessed type int __fastcall _errno(_DWORD);
// 5BC8: using guessed type _DWORD dword_5BC8[6];
// 2B08: using guessed type char var_148[288];

//----- (00003054) --------------------------------------------------------
int __fastcall pcm_mmap_avail(int a1)
{
  _DWORD *v2; // r0
  int v3; // r0
  __int64 v4; // kr00_8
  int v5; // r2
  int result; // r0

  v2 = *(_DWORD **)(a1 + 200);
  if ( v2 )
  {
    *v2 = 1;
    ioctl(*(_DWORD *)a1, 0xC0844123, *(_DWORD *)(a1 + 200));
  }
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 192) + 8);
  if ( (*(_BYTE *)(a1 + 7) & 0x10) != 0 )
  {
    result = v3 - **(_DWORD **)(a1 + 196);
    if ( result <= -1 )
      result += *(_DWORD *)(a1 + 20);
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 16);
    v5 = v3 + v4 - **(_DWORD **)(a1 + 196);
    if ( v5 > -1 )
    {
      result = v5 - HIDWORD(v4);
      if ( v5 <= SHIDWORD(v4) )
        return v5;
    }
    else
    {
      return v5 + HIDWORD(v4);
    }
  }
  return result;
}

//----- (000030B8) --------------------------------------------------------
int __fastcall pcm_mmap_begin(int a1, _DWORD *a2, int *a3, unsigned int *a4)
{
  unsigned int v7; // r0
  unsigned int v8; // r1
  unsigned int v9; // r1

  *a2 = *(_DWORD *)(a1 + 204);
  *a3 = **(_DWORD **)(a1 + 196) % *(_DWORD *)(a1 + 16);
  v7 = j_pcm_mmap_avail(a1);
  v8 = *(_DWORD *)(a1 + 16);
  if ( v7 > v8 )
    v7 = *(_DWORD *)(a1 + 16);
  v9 = v8 - *a3;
  if ( *a4 <= v7 )
    v7 = *a4;
  if ( v7 > v9 )
    v7 = v9;
  *a4 = v7;
  return 0;
}

//----- (000030FA) --------------------------------------------------------
int __fastcall pcm_mmap_commit(int *a1, int a2, int a3)
{
  unsigned int *v4; // r2
  unsigned int v5; // r1
  unsigned int v6; // r3
  bool v7; // cf
  unsigned int v8; // r1
  _DWORD *v9; // r1

  v4 = (unsigned int *)a1[49];
  v5 = a1[5];
  v6 = *v4 + a3;
  v7 = v6 >= v5;
  v8 = v6 - v5;
  if ( v8 == 0 || !v7 )
    v8 = *v4 + a3;
  *v4 = v8;
  v9 = (_DWORD *)a1[50];
  if ( v9 )
  {
    *v9 = 0;
    ioctl(*a1, 0xC0844123, a1[50]);
  }
  return a3;
}

//----- (00003132) --------------------------------------------------------
int __fastcall pcm_avail_update(int *a1)
{
  _DWORD *v2; // r0

  v2 = (_DWORD *)a1[50];
  if ( v2 )
  {
    *v2 = 0;
    ioctl(*a1, 0xC0844123, a1[50]);
  }
  return j_j_pcm_mmap_avail((int)a1);
}

//----- (0000315C) --------------------------------------------------------
int __fastcall pcm_state(int a1)
{
  _DWORD *v2; // r0

  v2 = *(_DWORD **)(a1 + 200);
  if ( v2 && (*v2 = 0, ioctl(*(_DWORD *)a1, 0xC0844123, *(_DWORD *)(a1 + 200)) < 0) )
    return -1;
  else
    return **(_DWORD **)(a1 + 192);
}

//----- (0000318E) --------------------------------------------------------
int __fastcall pcm_set_avail_min(int a1, Elf32_Dyn *a2)
{
  if ( (*(_DWORD *)(a1 + 4) & 3) != 3 )
    return -38;
  *(Elf32_Dyn **)((char *)off_BC + a1) = a2;
  return 0;
}
// BC: using guessed type Elf32_Dyn *[2];

//----- (000031A4) --------------------------------------------------------
int __fastcall pcm_wait(int *a1, int a2)
{
  int v4; // r0
  int v5; // r1
  bool v6; // zf
  unsigned int v8; // r0
  int v9; // [sp+0h] [bp-20h] BYREF
  __int16 v10; // [sp+4h] [bp-1Ch]
  __int16 v11; // [sp+6h] [bp-1Ah]

  v9 = *a1;
  v10 = 44;
  while ( 1 )
  {
    v4 = ((int (__fastcall *)(int *, int, int, int))_poll_chk)(&v9, 1, a2, 8);
    if ( v4 <= -1 )
      return -*(_DWORD *)_errno(v4);
    if ( !v4 )
      return 0;
    v5 = *(_DWORD *)_errno(v4);
    v6 = v5 == -4;
    if ( v5 != -4 )
      v6 = (v11 & 0x28) == 0;
    if ( !v6 )
      break;
    if ( (v11 & 5) != 0 )
      return 1;
  }
  v8 = j_pcm_state((int)a1) - 4;
  if ( v8 >= 5 )
    return -5;
  else
    return dword_5C20[v8];
}
// 1610: using guessed type int __fastcall _errno(_DWORD);
// 16D0: using guessed type int __fastcall _poll_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 5C20: using guessed type _DWORD dword_5C20[5];

//----- (00003248) --------------------------------------------------------
int __fastcall pcm_get_poll_fd(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0000324C) --------------------------------------------------------
int __fastcall pcm_mmap_transfer(int a1, int a2, unsigned int a3)
{
  unsigned int v5; // r1
  int v6; // r1
  int v7; // r4
  unsigned int v8; // r8
  int v9; // r7
  char v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r11
  int v14; // r6
  int v15; // r4
  int v16; // r0
  unsigned int v17; // r1
  unsigned int v18; // r5
  int v19; // r0
  int v20; // r3
  unsigned int v21; // r1
  int v22; // r2
  int v23; // r3
  int v24; // r1
  size_t v25; // r2
  int v26; // r4
  int v27; // r3
  void *v28; // r0
  const void *v29; // r1
  int v30; // r1
  int v31; // r0
  int v32; // r4
  int v33; // r0
  int v34; // r1
  int v36; // r0
  int v37; // [sp+8h] [bp-30h]
  int v38; // [sp+Ch] [bp-2Ch]
  int v39; // [sp+10h] [bp-28h]

  if ( !a3 )
    return 0;
  v5 = *(_DWORD *)(a1 + 168) - 1;
  if ( v5 > 3 )
    v6 = 2;
  else
    v6 = *(_DWORD *)&asc_5BB8[4 * v5] >> 3;
  v7 = 0;
  v8 = a3 / (*(_DWORD *)(a1 + 152) * v6);
  v39 = 0;
  while ( 1 )
  {
    v37 = v7;
    if ( !v8 )
      return 0;
LABEL_7:
    v9 = j_pcm_avail_update((int *)a1);
    if ( v9 <= -1 )
    {
      fwrite("cannot determine available mmap frames", 0x26u, 1u, stderr);
      return v37;
    }
    v10 = *(_BYTE *)(a1 + 8);
    if ( (v10 & 1) == 0 && (unsigned int)(*(_DWORD *)(a1 + 16) - v9) >= *(_DWORD *)(a1 + 172) )
    {
      if ( j_pcm_start(a1) <= -1 )
      {
        v36 = fprintf(
                stderr,
                "start error: hw 0x%x app 0x%x avail 0x%x\n",
                *(_DWORD *)(*(_DWORD *)(a1 + 192) + 8),
                **(_DWORD **)(a1 + 196),
                v9);
        return -*(_DWORD *)_errno(v36);
      }
      *(_DWORD *)(a1 + 212) = 0;
      v10 = *(_BYTE *)(a1 + 8);
    }
    if ( (v10 & 1) == 0 )
      break;
    v11 = *(_DWORD *)(a1 + 212);
    if ( v8 <= v9 || v11 )
    {
      if ( !v11 )
        break;
    }
    else
    {
      *(_DWORD *)(a1 + 212) = 1;
    }
    v12 = *(_DWORD *)(a1 + 188);
    if ( v12 <= v9 )
      break;
    *(_DWORD *)(a1 + 212) = 0;
    if ( (*(_BYTE *)(a1 + 4) & 2) != 0 )
      v34 = (unsigned int)(v12 - v9) / *(_DWORD *)(a1 + 208);
    else
      v34 = -1;
    v7 = j_pcm_wait((int *)a1, v34);
    if ( v7 <= -1 )
    {
      *(_BYTE *)(a1 + 8) &= 0xFCu;
      sub_22EC(
        a1,
        v7,
        (int)"wait error: hw 0x%x app 0x%x avail 0x%x\n",
        *(_DWORD *)(*(_DWORD *)(a1 + 192) + 8),
        **(_DWORD **)(a1 + 196),
        v9);
      v14 = v7;
      **(_DWORD **)(a1 + 196) = 0;
      return v14;
    }
  }
  v38 = v9;
  if ( (int)v8 <= v9 )
    v9 = v8;
  v13 = v39;
  v14 = 0;
  if ( !v9 )
    return v14;
  do
  {
    v15 = **(_DWORD **)(a1 + 196) % *(_DWORD *)(a1 + 16);
    v16 = j_pcm_mmap_avail(a1);
    v17 = *(_DWORD *)(a1 + 16);
    v18 = v16;
    v19 = *(_DWORD *)(a1 + 152);
    v20 = *(_DWORD *)(a1 + 168);
    if ( v18 > v17 )
      v18 = *(_DWORD *)(a1 + 16);
    v21 = v17 - v15;
    if ( v9 <= v18 )
      v18 = v9;
    if ( v18 > v21 )
      v18 = v21;
    v22 = v18 * v19;
    if ( (unsigned int)(v20 - 1) >= 4 )
    {
      v25 = 2 * v22;
      v23 = 2;
      v24 = 2 * v15 * v19;
    }
    else
    {
      v23 = *(_DWORD *)&asc_5BB8[4 * v20 - 4] >> 3;
      v24 = v15 * v19 * v23;
      v25 = v22 * v23;
    }
    v26 = *(_DWORD *)(a1 + 204);
    v27 = v23 * v19 * v13;
    if ( (*(_BYTE *)(a1 + 7) & 0x10) != 0 )
    {
      v28 = (void *)(a2 + v27);
      v29 = (const void *)(v24 + v26);
    }
    else
    {
      v28 = (void *)(v26 + v24);
      v29 = (const void *)(a2 + v27);
    }
    qmemcpy(v28, v29, v25);
    v31 = j_pcm_mmap_commit((int *)a1, v30, v18);
    v32 = v31;
    if ( v31 <= -1 )
    {
      sub_22EC(a1, v31, (int)"failed to commit %d frames\n", v18);
      v14 = v32;
      goto LABEL_44;
    }
    v9 -= v31;
    v14 += v31;
    v13 += v31;
  }
  while ( v9 );
  if ( v14 <= -1 )
  {
LABEL_44:
    fprintf(
      stderr,
      "write error: hw 0x%x app 0x%x avail 0x%x\n",
      *(_DWORD *)(*(_DWORD *)(a1 + 192) + 8),
      **(_DWORD **)(a1 + 196),
      v38);
    return v14;
  }
  v8 -= v14;
  v33 = v39 + v14;
  v14 = 0;
  v39 = v33;
  if ( v8 )
    goto LABEL_7;
  return v14;
}
// 3390: variable 'v30' is possibly undefined
// 1610: using guessed type int __fastcall _errno(_DWORD);

//----- (000034BC) --------------------------------------------------------
int __fastcall pcm_mmap_write(int a1, int a2, unsigned int a3)
{
  if ( (*(_BYTE *)(a1 + 4) & 1) != 0 )
    return j_j_pcm_mmap_transfer(a1, a2, a3);
  else
    return -38;
}

//----- (000034CE) --------------------------------------------------------
int __fastcall pcm_mmap_read(int a1, int a2, unsigned int a3)
{
  if ( (*(_DWORD *)(a1 + 4) & 0x10000001) == 268435457 )
    return j_j_pcm_mmap_transfer(a1, a2, a3);
  else
    return -38;
}

//----- (000034EC) --------------------------------------------------------
int __fastcall pcm_ioctl(int *a1, unsigned int a2, int a3)
{
  if ( a1 && *a1 >= 0 )
    return ioctl(*a1, a2, a3);
  else
    return -1;
}

//----- (0000354C) --------------------------------------------------------
int __fastcall pcm_get_trigger_tstamp(int *a1, _DWORD *a2)
{
  int result; // r0
  _DWORD v5[27]; // [sp+0h] [bp-78h] BYREF

  result = -1;
  if ( a1 )
  {
    if ( a2 )
    {
      result = j_pcm_ioctl(a1, 0x806C4120, (int)v5);
      *a2 = v5[1];
      a2[1] = v5[2] / 1000;
    }
  }
  return result;
}

//----- (000035B0) --------------------------------------------------------
int __fastcall pcm_get_xrun(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (000035B4) --------------------------------------------------------
unsigned int *__fastcall sub_35B4(unsigned int *result, int *a2, int *a3)
{
  unsigned int v3; // r3
  unsigned int v4; // t1
  int v5; // r12
  bool v6; // zf
  int v7; // r3
  int v8; // r12

  v3 = *result;
  if ( (*result & 0x80000000) == 0 )
  {
    *a2 = 1;
    v4 = result[1];
    ++result;
    *a3 = 4 * HIBYTE(v4) + 4;
    return result;
  }
  v5 = HIBYTE(v3) & 0xF;
  if ( v5 )
  {
    v6 = v5 == 3;
    if ( v5 != 3 )
      v6 = v5 == 1;
    if ( !v6 )
      return 0;
    v7 = 4 * BYTE2(v3) + 4;
    v8 = 2;
  }
  else
  {
    v8 = 1;
    v7 = 4;
  }
  *a3 = v7;
  *a2 = v8;
  return result;
}

//----- (00003608) --------------------------------------------------------
int __fastcall sub_3608(int a1, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v6; // r11
  unsigned int v8; // r7
  int v9; // r10
  int v10; // r2
  unsigned int v11; // r1
  int result; // r0
  int v13; // r3
  int v14; // r2
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r1
  int v19; // r6
  int v20; // r2
  int v21; // r0
  int v22; // r1
  int v23; // r3
  int v24; // r0
  int v25; // r0
  unsigned int v32; // r1
  unsigned int v33; // r0
  int v34; // r1
  unsigned int v35; // r0
  int v36; // [sp+0h] [bp-30h]
  int v37; // [sp+4h] [bp-2Ch] BYREF

  v6 = a3;
  if ( a3 >= a4 )
  {
LABEL_54:
    sub_3F04(a1, 14, &v37);
    sub_3F32(a1, 15, v37);
    return 8;
  }
  v36 = 0;
  do
  {
    v8 = v6 + 1;
    v9 = *(unsigned __int8 *)(a2 + (v6 ^ 3));
    if ( (v9 & 0x80) == 0 )
    {
      sub_3F04(a1, 13, &v37);
      if ( (v9 & 0x40) != 0 )
        v10 = -4 - (unsigned __int8)(4 * v9) + v37;
      else
        v10 = 4 * v9 + v37 + 4;
LABEL_12:
      v37 = v10;
LABEL_13:
      sub_3F32(a1, 13, v10);
LABEL_36:
      v6 = v8;
      continue;
    }
    v11 = v9 & 0xF0;
    result = 9;
    if ( v11 > 0xAF )
    {
      if ( v11 == 176 )
      {
        result = 9;
        v18 = 0;
        v19 = 0;
        switch ( *(_BYTE *)(a2 + (v6 ^ 3)) )
        {
          case 0xB0:
            goto LABEL_53;
          case 0xB1:
            if ( v8 >= a4 )
              return 9;
            v20 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
            result = 9;
            if ( !*(_BYTE *)(a2 + (v8 ^ 3)) || (v20 & 0xF0) != 0 )
              return result;
            v21 = a1;
            v22 = 0;
            v23 = 0;
            goto LABEL_48;
          case 0xB2:
            break;
          case 0xB3:
            v23 = 1;
            v25 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
            _R1 = v25 << 12;
            __asm { UXTB16.W        R1, R1 }
            v20 = ((v25 & 0xF) + 1) | _R1;
            v21 = a1;
            v22 = 1;
            goto LABEL_48;
          case 0xB4:
          case 0xB5:
          case 0xB6:
          case 0xB7:
            return result;
          default:
            v16 = 1;
            v13 = 1;
            v14 = ((v9 & 7) + 1) | 0x80000;
            v15 = a1;
            goto LABEL_35;
        }
        while ( v8 < a4 )
        {
          v24 = v8++ ^ 3;
          LOBYTE(v24) = *(_BYTE *)(a2 + v24);
          v19 |= (v24 & 0x7F) << v18;
          v18 += 7;
          if ( (v24 & 0x80) == 0 )
          {
            sub_3F04(a1, 13, &v37);
            v10 = v37 + 4 * v19 + 516;
            goto LABEL_12;
          }
        }
        return 9;
      }
      if ( v11 != 192 )
      {
        if ( v11 != 208 )
          return result;
        if ( (v9 & 8) != 0 )
          return 9;
        v16 = 1;
        v14 = ((v9 & 7) + 1) | 0x80000;
        v15 = a1;
LABEL_34:
        v13 = 5;
        goto LABEL_35;
      }
      switch ( *(_BYTE *)(a2 + (v6 ^ 3)) )
      {
        case 0xC0:
        case 0xC1:
        case 0xC2:
        case 0xC3:
        case 0xC4:
        case 0xC5:
          v16 = 3;
          v14 = ((v9 & 7) + 1) | 0xA0000;
          v15 = a1;
          goto LABEL_34;
        case 0xC6:
          v35 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
          if ( (v35 & 0xF) + (v35 >> 4) > 0xF )
            return 9;
          v20 = ((v35 & 0xF) + 1) | (v35 >> 4 << 16);
          v21 = a1;
          v22 = 3;
          break;
        case 0xC7:
          if ( !*(_BYTE *)(a2 + (v8 ^ 3)) || *(unsigned __int8 *)(a2 + (v8 ^ 3)) >= 0x10u )
            return 9;
          goto LABEL_49;
        case 0xC8:
        case 0xC9:
          v32 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
          v33 = v32 >> 4;
          if ( v9 == 200 )
            v33 = (v32 >> 4) | 0x10;
          v34 = v32 & 0xF;
          if ( v33 + v34 > 0x1F )
            return 9;
          v20 = (v34 + 1) | (v33 << 16);
          v21 = a1;
          v22 = 1;
          break;
        default:
          return 9;
      }
      v23 = 5;
LABEL_48:
      sub_39E8(v21, v22, v20, v23);
    }
    else
    {
      if ( v11 != 128 )
      {
        if ( v11 == 144 )
        {
          if ( (v9 & 0xD | 2) == 15 )
            return 9;
          sub_3F04(a1, v9 & 0xF, &v37);
          v10 = v37;
          goto LABEL_13;
        }
        if ( v11 != 160 )
          return result;
        v13 = 0;
        v14 = ((16 << ((v9 & 7) + 1)) - 16) | (v9 << 11) & 0x4000;
        v15 = a1;
        v16 = 0;
LABEL_35:
        sub_39E8(v15, v16, v14, v13);
        goto LABEL_36;
      }
      if ( v8 >= a4 )
        return 9;
      v17 = (unsigned __int16)((_WORD)v9 << 12) | (16 * *(unsigned __int8 *)(a2 + (v8 ^ 3)));
      if ( !v17 )
        return 9;
      sub_39E8(a1, 0, v17, 0);
      v36 |= (unsigned __int16)(((_WORD)v9 << 12) & 0x8000) >> 15;
    }
LABEL_49:
    v6 += 2;
  }
  while ( v6 < a4 );
LABEL_53:
  if ( (v36 & 1) == 0 )
    goto LABEL_54;
  return 8;
}

//----- (000038B8) --------------------------------------------------------
int __fastcall sub_38B8(int a1, int a2, unsigned int a3, int a4, _QWORD *a5)
{
  int result; // r0
  int v8; // r0
  int v9; // r1
  int v10; // r1

  switch ( a2 )
  {
    case 0:
      result = 2;
      if ( a3 > 0xF || a4 )
        return result;
      v8 = a1;
      v9 = a3;
      goto LABEL_11;
    case 1:
      if ( a4 == 5 )
      {
        if ( a3 <= 0x1F )
          goto LABEL_19;
        return 2;
      }
      if ( a4 != 1 || a3 > 0xF )
        return 2;
      sub_4014(a1);
LABEL_19:
      v10 = a3 + 256;
LABEL_20:
      result = sub_3F76(a1, v10, a5);
LABEL_21:
      if ( result )
        return 2;
      return result;
    case 3:
      result = 2;
      if ( a3 > 0x1F || a4 != 5 )
        return result;
      v10 = a3 + 112;
      goto LABEL_20;
    case 4:
      result = 2;
      if ( a3 > 3 || a4 )
        return result;
      v9 = a3 + 192;
      v8 = a1;
LABEL_11:
      result = sub_3F04(v8, v9, a5);
      goto LABEL_21;
    default:
      sub_3D6C(
        "_Unwind_VRS_Result _Unwind_VRS_Get_Internal(_Unwind_Context *, _Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataR"
        "epresentation, void *)",
        885,
        "unsupported register class");
  }
}

//----- (0000394C) --------------------------------------------------------
int __fastcall sub_394C(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  int result; // r0
  int v8; // r2
  int v9; // r0
  int v10; // r1
  __int64 v11; // r2
  int v12; // r1

  switch ( a2 )
  {
    case 0:
      result = 2;
      if ( a3 > 0xF || a4 )
        return result;
      v8 = *a5;
      v9 = a1;
      v10 = a3;
      goto LABEL_11;
    case 1:
      if ( a4 == 5 )
      {
        if ( a3 <= 0x1F )
          goto LABEL_19;
        return 2;
      }
      if ( a4 != 1 || a3 > 0xF )
        return 2;
      sub_4014(a1);
LABEL_19:
      v11 = *(_QWORD *)a5;
      v12 = a3 + 256;
LABEL_20:
      result = sub_3FA6(a1, v12, v11, SHIDWORD(v11));
LABEL_21:
      if ( result )
        return 2;
      return result;
    case 3:
      result = 2;
      if ( a3 > 0x1F || a4 != 5 )
        return result;
      v11 = *(_QWORD *)a5;
      v12 = a3 + 112;
      goto LABEL_20;
    case 4:
      result = 2;
      if ( a3 > 3 || a4 )
        return result;
      v8 = *a5;
      v10 = a3 + 192;
      v9 = a1;
LABEL_11:
      result = sub_3F32(v9, v10, v8);
      goto LABEL_21;
    default:
      sub_3D6C(
        "_Unwind_VRS_Result _Unwind_VRS_Set(_Unwind_Context *, _Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataRepresentation, void *)",
        837,
        "unsupported register class");
  }
}

//----- (000039E8) --------------------------------------------------------
int __fastcall sub_39E8(int a1, int a2, unsigned int a3, int a4)
{
  char v8; // r4
  unsigned int i; // r7
  int *v10; // r0
  int result; // r0
  unsigned int v12; // r4
  unsigned int v13; // r6
  int *v14; // r0
  int v15; // r2
  int v16; // r0
  int v17; // r2
  int v18[2]; // [sp+8h] [bp-30h] BYREF
  int *v19; // [sp+10h] [bp-28h] BYREF

  switch ( a2 )
  {
    case 0:
    case 4:
      if ( a4 || sub_3F04(a1, 13, v18) )
        return 2;
      v8 = 0;
      for ( i = 0; i < 0x10; ++i )
      {
        if ( ((1 << i) & a3) != 0 )
        {
          v10 = (int *)v18[0];
          v18[0] += 4;
          v19 = (int *)*v10;
          if ( sub_394C(a1, a2, i, 0, (int *)&v19) )
            return 2;
          v8 |= a2 == 0 && i == 13;
        }
      }
      if ( (v8 & 1) != 0 )
        return 0;
      v17 = v18[0];
      goto LABEL_22;
    case 1:
    case 3:
      if ( (a4 | 4) != 5 || sub_3F04(a1, 13, &v19) )
        return 2;
      if ( !(_WORD)a3 )
        goto LABEL_17;
      v12 = HIWORD(a3);
      v13 = HIWORD(a3) + (unsigned __int16)a3;
      break;
    default:
      sub_3D6C(
        "_Unwind_VRS_Result _Unwind_VRS_Pop(_Unwind_Context *, _Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataRepresentation)",
        971,
        "unsupported register class");
  }
  do
  {
    v14 = v19++;
    v15 = *v14;
    v19 = v14 + 2;
    v16 = v14[1];
    v18[0] = v15;
    v18[1] = v16;
    if ( sub_394C(a1, a2, v12, a4, v18) )
      return 2;
    ++v12;
  }
  while ( v12 < v13 );
LABEL_17:
  if ( a4 == 1 )
    v17 = (int)++v19;
  else
    v17 = (int)v19;
LABEL_22:
  result = sub_3F32(a1, 13, v17);
  if ( result )
    return 2;
  return result;
}

//----- (00003B28) --------------------------------------------------------
int __fastcall sub_3B28(int a1, int a2, int a3)
{
  return sub_3B30(a2, a3);
}

//----- (00003B30) --------------------------------------------------------
int __fastcall sub_3B30(int a1, int a2)
{
  int result; // r0
  int v5; // r1
  char v6[8]; // [sp+4h] [bp-3Ch] BYREF
  _DWORD *v7; // [sp+Ch] [bp-34h]

  sub_3FE4(a2, (int)v6);
  if ( (*(_BYTE *)(a1 + 80) & 1) == 0 && *v7 )
    return 9;
  v5 = sub_3FDE(a2);
  result = 9;
  if ( v5 == 1 )
    return 8;
  return result;
}
// 3B30: using guessed type char var_3C[8];

//----- (00003B8C) --------------------------------------------------------
int __fastcall sub_3B8C(int a1, int a2, int a3)
{
  return sub_3B30(a2, a3);
}

//----- (00003B94) --------------------------------------------------------
int __fastcall sub_3B94(int a1, int a2, int a3)
{
  return sub_3B30(a2, a3);
}

//----- (00003B9C) --------------------------------------------------------
int __fastcall sub_3B9C(int *a1, int a2, int a3, int a4)
{
  int v5; // r5
  int (__fastcall *v6)(_DWORD, int *, char *); // r3
  int v7; // r0
  int v9[3]; // [sp+0h] [bp-8A0h] BYREF
  int (__fastcall *v10)(_DWORD, int *, char *); // [sp+Ch] [bp-894h]
  int v11; // [sp+14h] [bp-88Ch]
  int v12; // [sp+20h] [bp-880h]
  _DWORD v13[256]; // [sp+28h] [bp-878h] BYREF
  char v14[1120]; // [sp+428h] [bp-478h] BYREF

  sub_3E38(v13, a2, a3, a4, v9[0]);
  a1[3] = 0;
  sub_3EC0((int)v14, v13);
  if ( sub_3FE4((int)v14, (int)v9) )
    return 3;
  v5 = 3;
  while ( 1 )
  {
    v6 = v10;
    if ( v10 )
    {
      a1[18] = v9[0];
      a1[19] = v12;
      a1[20] = v11;
      v7 = v6(0, a1, v14);
      if ( v7 != 8 )
        break;
    }
    if ( sub_3FE4((int)v14, (int)v9) )
      return 3;
  }
  if ( v7 == 6 )
  {
    sub_3C48(v13, a1, 0);
    return 2;
  }
  else if ( v7 == 9 )
  {
    return 9;
  }
  return v5;
}
// 3B9C: using guessed type _DWORD var_878[256];

//----- (00003C48) --------------------------------------------------------
int __fastcall sub_3C48(const void *a1, int *a2, char a3)
{
  int i; // r6
  int v6; // r7
  int (__fastcall *v7)(int, int *, char *); // r3
  int v8; // r0
  int v10; // [sp+0h] [bp-4B8h] BYREF
  int v11[3]; // [sp+4h] [bp-4B4h] BYREF
  int (__fastcall *v12)(int, int *, char *); // [sp+10h] [bp-4A8h]
  int v13; // [sp+18h] [bp-4A0h]
  int v14; // [sp+24h] [bp-494h]
  int v15; // [sp+2Ch] [bp-48Ch] BYREF
  char v16[1124]; // [sp+30h] [bp-488h] BYREF
  int v17; // [sp+494h] [bp-24h]

  sub_3EC0((int)v16, a1);
  for ( i = 1; ; --i )
  {
    v6 = 1;
    if ( (a3 & 1) != 0 )
    {
      v6 = 2;
      if ( !i )
      {
        sub_3F32((int)v16, -1, a2[4]);
        a3 = 0;
      }
    }
    sub_3F04((int)v16, -2, &v15);
    if ( sub_3FE4((int)v16, (int)v11) )
      break;
    v7 = v12;
    if ( v12 )
    {
      a2[18] = v11[0];
      a2[19] = v14;
      a2[20] = v13;
      v8 = v7(v6, a2, v16);
      if ( v8 == 7 )
      {
        sub_3F04((int)v16, -1, &v10);
        a2[4] = v10;
        sub_4002((int)v16);
        return _stack_chk_guard - v17;
      }
      if ( v8 != 8 )
      {
        if ( v8 == 9 )
          abort();
        return _stack_chk_guard - v17;
      }
      if ( v15 == a2[8] )
        sub_3D6C(
          "_Unwind_Reason_Code unwind_phase2(unw_context_t *, _Unwind_Exception *, bool)",
          653,
          "during phase1 personality function said it would stop here, but now in phase2 it did not stop here");
    }
  }
  return _stack_chk_guard - v17;
}
// 3C48: using guessed type int var_4B4[3];

//----- (00003D38) --------------------------------------------------------
void __fastcall __noreturn sub_3D38(int *a1, int a2, int a3, int a4)
{
  int v5[260]; // [sp+0h] [bp-410h] BYREF

  sub_3E38(v5, a2, a3, a4, v5[0]);
  sub_3C48(v5, a1, 1);
  sub_3D6C("void _Unwind_Resume(_Unwind_Exception *)", 753, "_Unwind_Resume() can't return");
}

//----- (00003D6C) --------------------------------------------------------
void __fastcall __noreturn sub_3D6C(const char *a1, int a2, const char *a3)
{
  fprintf(stderr, "libunwind: %s %s:%d - %s\n", a1, "external/libunwind_llvm/src/Unwind-EHABI.cpp", a2, a3);
  abort();
}

//----- (00003DA0) --------------------------------------------------------
int __fastcall sub_3DA0(int a1)
{
  bool v1; // zf
  int result; // r0
  char v3[8]; // [sp+4h] [bp-34h] BYREF
  int v4; // [sp+Ch] [bp-2Ch]

  v1 = sub_3FE4(a1, (int)v3) == 0;
  result = v4;
  if ( !v1 )
    return 0;
  return result;
}
// 3DA0: using guessed type char var_34[8];

//----- (00003DDC) --------------------------------------------------------
int __fastcall sub_3DDC(int a1)
{
  bool v1; // zf
  int result; // r0
  int v3[10]; // [sp+4h] [bp-34h] BYREF

  v1 = sub_3FE4(a1, (int)v3) == 0;
  result = v3[0];
  if ( !v1 )
    return 0;
  return result;
}
// 3DDC: using guessed type int var_34[10];

//----- (00003E24) --------------------------------------------------------
int __fastcall sub_3E24(int a1, int a2)
{
  int v2; // r0
  int v3; // r1

  v2 = sub_3FDE(a2);
  v3 = 9;
  if ( v2 == 1 )
    return 0;
  return v3;
}

//----- (00003E38) --------------------------------------------------------
int __fastcall sub_3E38(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  int v6; // r5
  int v7; // r6
  int v8; // r7
  int v9; // r8
  int v10; // r9
  int v11; // r10
  int v12; // r11
  int v13; // r12
  int v14; // lr

  *a1 = a1;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  a1[4] = v5;
  a1[5] = v6;
  a1[6] = v7;
  a1[7] = v8;
  a1[8] = v9;
  a1[9] = v10;
  a1[10] = v11;
  a1[11] = v12;
  a1[12] = v13;
  a1[13] = &a5;
  a1[14] = v14;
  a1[15] = v14;
  return 0;
}
// 3E38: variable 'v5' is possibly undefined
// 3E38: variable 'v6' is possibly undefined
// 3E38: variable 'v7' is possibly undefined
// 3E38: variable 'v8' is possibly undefined
// 3E38: variable 'v9' is possibly undefined
// 3E38: variable 'v10' is possibly undefined
// 3E38: variable 'v11' is possibly undefined
// 3E38: variable 'v12' is possibly undefined
// 3E38: variable 'v13' is possibly undefined
// 3E40: variable 'v14' is possibly undefined

//----- (00003E50) --------------------------------------------------------
_QWORD *__fastcall sub_3E50(_QWORD *result)
{
  __int64 v1; // d0
  __int64 v2; // d1
  __int64 v3; // d2
  __int64 v4; // d3
  __int64 v5; // d4
  __int64 v6; // d5
  __int64 v7; // d6
  __int64 v8; // d7
  __int64 v9; // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// 3E50: variable 'v1' is possibly undefined
// 3E50: variable 'v2' is possibly undefined
// 3E50: variable 'v3' is possibly undefined
// 3E50: variable 'v4' is possibly undefined
// 3E50: variable 'v5' is possibly undefined
// 3E50: variable 'v6' is possibly undefined
// 3E50: variable 'v7' is possibly undefined
// 3E50: variable 'v8' is possibly undefined
// 3E50: variable 'v9' is possibly undefined
// 3E50: variable 'v10' is possibly undefined
// 3E50: variable 'v11' is possibly undefined
// 3E50: variable 'v12' is possibly undefined
// 3E50: variable 'v13' is possibly undefined
// 3E50: variable 'v14' is possibly undefined
// 3E50: variable 'v15' is possibly undefined
// 3E50: variable 'v16' is possibly undefined

//----- (00003E58) --------------------------------------------------------
_QWORD *__fastcall sub_3E58(_QWORD *result)
{
  __int64 v1; // d0
  __int64 v2; // d1
  __int64 v3; // d2
  __int64 v4; // d3
  __int64 v5; // d4
  __int64 v6; // d5
  __int64 v7; // d6
  __int64 v8; // d7
  __int64 v9; // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// 3E58: variable 'v1' is possibly undefined
// 3E58: variable 'v2' is possibly undefined
// 3E58: variable 'v3' is possibly undefined
// 3E58: variable 'v4' is possibly undefined
// 3E58: variable 'v5' is possibly undefined
// 3E58: variable 'v6' is possibly undefined
// 3E58: variable 'v7' is possibly undefined
// 3E58: variable 'v8' is possibly undefined
// 3E58: variable 'v9' is possibly undefined
// 3E58: variable 'v10' is possibly undefined
// 3E58: variable 'v11' is possibly undefined
// 3E58: variable 'v12' is possibly undefined
// 3E58: variable 'v13' is possibly undefined
// 3E58: variable 'v14' is possibly undefined
// 3E58: variable 'v15' is possibly undefined
// 3E58: variable 'v16' is possibly undefined

//----- (00003E60) --------------------------------------------------------
_QWORD *__fastcall sub_3E60(_QWORD *result)
{
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d18
  __int64 v4; // d19
  __int64 v5; // d20
  __int64 v6; // d21
  __int64 v7; // d22
  __int64 v8; // d23
  __int64 v9; // d24
  __int64 v10; // d25
  __int64 v11; // d26
  __int64 v12; // d27
  __int64 v13; // d28
  __int64 v14; // d29
  __int64 v15; // d30
  __int64 v16; // d31

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// 3E60: variable 'v1' is possibly undefined
// 3E60: variable 'v2' is possibly undefined
// 3E60: variable 'v3' is possibly undefined
// 3E60: variable 'v4' is possibly undefined
// 3E60: variable 'v5' is possibly undefined
// 3E60: variable 'v6' is possibly undefined
// 3E60: variable 'v7' is possibly undefined
// 3E60: variable 'v8' is possibly undefined
// 3E60: variable 'v9' is possibly undefined
// 3E60: variable 'v10' is possibly undefined
// 3E60: variable 'v11' is possibly undefined
// 3E60: variable 'v12' is possibly undefined
// 3E60: variable 'v13' is possibly undefined
// 3E60: variable 'v14' is possibly undefined
// 3E60: variable 'v15' is possibly undefined
// 3E60: variable 'v16' is possibly undefined

//----- (00003E68) --------------------------------------------------------
void sub_3E68()
{
  __asm
  {
    STCL            p1, c0, [R0],#8
    STCL            p1, c1, [R0],#8
    STCL            p1, c2, [R0],#8
    STCL            p1, c3, [R0],#8
    STCL            p1, c4, [R0],#8
    STCL            p1, c5, [R0],#8
    STCL            p1, c6, [R0],#8
    STCL            p1, c7, [R0],#8
    STCL            p1, c8, [R0],#8
    STCL            p1, c9, [R0],#8
    STCL            p1, c10, [R0],#8
    STCL            p1, c11, [R0],#8
    STCL            p1, c12, [R0],#8
    STCL            p1, c13, [R0],#8
    STCL            p1, c14, [R0],#8
    STCL            p1, c15, [R0],#8
  }
}

//----- (00003EAC) --------------------------------------------------------
void sub_3EAC()
{
  __asm
  {
    STC2            p1, c8, [R0],#4
    STC2            p1, c9, [R0],#4
    STC2            p1, c10, [R0],#4
    STC2            p1, c11, [R0],#4
  }
}

//----- (00003EC0) --------------------------------------------------------
int __fastcall sub_3EC0(int a1, const void *a2)
{
  *(_DWORD *)a1 = &off_6DC8;
  *(_DWORD *)(a1 + 4) = &unk_70DC;
  *(_BYTE *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  qmemcpy((void *)(a1 + 8), a2, 0x40u);
  memset((void *)(a1 + 80), 0, 0x1C2u);
  sub_43D8((int *)a1, 0);
  return 0;
}
// 6DC8: using guessed type void *;

//----- (00003F04) --------------------------------------------------------
int __fastcall sub_3F04(int a1, int a2, _DWORD *a3)
{
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 8))(a1) != 1 )
    return -6542;
  *a3 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 12))(a1, a2);
  return 0;
}

//----- (00003F32) --------------------------------------------------------
int __fastcall sub_3F32(int a1, int a2, int a3)
{
  int v6; // r5

  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 8))(a1) != 1 )
    return -6542;
  (*(void (__fastcall **)(int, int, int))(*(_DWORD *)a1 + 16))(a1, a2, a3);
  if ( a2 != -1 )
    return 0;
  v6 = 0;
  (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)a1 + 52))(a1, 0);
  return v6;
}

//----- (00003F76) --------------------------------------------------------
int __fastcall sub_3F76(int a1, int a2, _QWORD *a3)
{
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 20))(a1) != 1 )
    return -6542;
  *a3 = ((__int64 (__fastcall *)(int, int))*(_DWORD *)(*(_DWORD *)a1 + 24))(a1, a2);
  return 0;
}

//----- (00003FA6) --------------------------------------------------------
int __fastcall sub_3FA6(int a1, int a2, int a3, int a4)
{
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 20))(a1) != 1 )
    return -6542;
  (*(void (__fastcall **)(int, int, int, int))(*(_DWORD *)a1 + 28))(a1, a2, a3, a4);
  return 0;
}

//----- (00003FDE) --------------------------------------------------------
int __fastcall sub_3FDE(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 32))(a1);
}

//----- (00003FE4) --------------------------------------------------------
int __fastcall sub_3FE4(int a1, int a2)
{
  int result; // r0

  (*(void (__fastcall **)(int, int))(*(_DWORD *)a1 + 36))(a1, a2);
  result = 0;
  if ( !*(_DWORD *)(a2 + 4) )
    return -6549;
  return result;
}

//----- (00004002) --------------------------------------------------------
int __fastcall sub_4002(int a1)
{
  (*(void (__fastcall **)(int))(*(_DWORD *)a1 + 40))(a1);
  return -6540;
}

//----- (00004014) --------------------------------------------------------
int __fastcall sub_4014(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 60))(a1);
}

//----- (0000401A) --------------------------------------------------------
bool __fastcall sub_401A(int a1, int a2)
{
  return (a2 & 0xFFFFFFFC) == 192 || (unsigned int)(a2 - 16) > 0xFFFFFFED;
}

//----- (0000403C) --------------------------------------------------------
int __fastcall sub_403C(int a1, int a2)
{
  int v4; // r0

  if ( a2 > 12 )
  {
    if ( a2 != 15 )
    {
      if ( a2 == 14 )
      {
        v4 = a1 + 64;
        return *(_DWORD *)v4;
      }
      if ( a2 != 13 )
        goto LABEL_11;
LABEL_9:
      v4 = a1 + 60;
      return *(_DWORD *)v4;
    }
    goto LABEL_8;
  }
  if ( a2 == -2 )
    goto LABEL_9;
  if ( a2 == -1 )
  {
LABEL_8:
    v4 = a1 + 68;
    return *(_DWORD *)v4;
  }
LABEL_11:
  if ( (unsigned int)a2 > 0xC )
  {
    if ( (a2 & 0xFFFFFFFC) != 192 )
      sub_4458(
        "uint32_t libunwind::Registers_arm::getRegister(int)",
        "external/libunwind_llvm/src/Registers.hpp",
        1452,
        "unsupported arm register");
    if ( !*(_BYTE *)(a1 + 76) )
    {
      *(_BYTE *)(a1 + 76) = 1;
      sub_3EAC();
    }
    v4 = a1 + 4 * a2 - 296;
  }
  else
  {
    v4 = a1 + 4 * a2 + 8;
  }
  return *(_DWORD *)v4;
}

//----- (000040C8) --------------------------------------------------------
int __fastcall sub_40C8(int result, int a2, int a3)
{
  int v5; // r5

  v5 = result;
  if ( a2 > 12 )
  {
    if ( a2 != 15 )
    {
      if ( a2 == 14 )
      {
        *(_DWORD *)(result + 64) = a3;
        return result;
      }
      if ( a2 != 13 )
        goto LABEL_11;
LABEL_10:
      *(_DWORD *)(result + 60) = a3;
      return result;
    }
    goto LABEL_9;
  }
  if ( a2 == -2 )
    goto LABEL_10;
  if ( a2 == -1 )
  {
LABEL_9:
    *(_DWORD *)(result + 68) = a3;
    return result;
  }
LABEL_11:
  if ( (unsigned int)a2 > 0xC )
  {
    if ( (a2 & 0xFFFFFFFC) != 192 )
      sub_4458(
        "void libunwind::Registers_arm::setRegister(int, uint32_t)",
        "external/libunwind_llvm/src/Registers.hpp",
        1471,
        "unsupported arm register");
    if ( !*(_BYTE *)(result + 76) )
    {
      *(_BYTE *)(result + 76) = 1;
      sub_3EAC();
    }
    result = v5 + 4 * a2;
    *(_DWORD *)(result - 296) = a3;
  }
  else
  {
    result += 4 * a2;
    *(_DWORD *)(result + 8) = a3;
  }
  return result;
}

//----- (00004154) --------------------------------------------------------
bool __fastcall sub_4154(int a1, int a2)
{
  return (a2 & 0xFFFFFFF0) == 112 || (a2 & 0xFFFFFFE0) == 256;
}

//----- (00004174) --------------------------------------------------------
__int64 __fastcall sub_4174(int a1, int a2)
{
  unsigned int v4; // r0
  _QWORD *v5; // r0
  int v6; // r0

  v4 = a2 & 0xFFFFFFF0;
  if ( (a2 & 0xFFFFFFF0) == 112 )
  {
    if ( !*(_BYTE *)(a1 + 75) )
    {
      *(_BYTE *)(a1 + 75) = 1;
      sub_3E68();
    }
    v6 = a1 + 8 * a2 - 552;
  }
  else if ( v4 == 272 )
  {
    if ( !*(_BYTE *)(a1 + 74) )
    {
      *(_BYTE *)(a1 + 74) = 1;
      sub_3E60((_QWORD *)(a1 + 216));
    }
    v6 = a1 + 8 * a2 - 1960;
  }
  else
  {
    if ( v4 != 256 )
      sub_4458(
        "unw_fpreg_t libunwind::Registers_arm::getFloatRegister(int)",
        "external/libunwind_llvm/src/Registers.hpp",
        1673,
        "Unknown ARM float register");
    if ( !*(_BYTE *)(a1 + 73) )
    {
      *(_BYTE *)(a1 + 73) = 1;
      v5 = (_QWORD *)(a1 + 80);
      if ( *(_BYTE *)(a1 + 72) )
        sub_3E58(v5);
      else
        sub_3E50(v5);
    }
    v6 = a1 + 8 * a2 - 1968;
  }
  return *(_QWORD *)v6;
}

//----- (00004218) --------------------------------------------------------
int __fastcall sub_4218(int a1, int a2, int a3, int a4)
{
  unsigned int v6; // r0
  _QWORD *v9; // r0
  int result; // r0
  int v11; // r1

  v6 = a2 & 0xFFFFFFF0;
  if ( (a2 & 0xFFFFFFF0) == 112 )
  {
    if ( !*(_BYTE *)(a1 + 75) )
    {
      *(_BYTE *)(a1 + 75) = 1;
      sub_3E68();
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 548) = a4;
    LOWORD(v11) = -552;
  }
  else if ( v6 == 272 )
  {
    if ( !*(_BYTE *)(a1 + 74) )
    {
      *(_BYTE *)(a1 + 74) = 1;
      sub_3E60((_QWORD *)(a1 + 216));
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 1956) = a4;
    LOWORD(v11) = -1960;
  }
  else
  {
    if ( v6 != 256 )
      sub_4458(
        "void libunwind::Registers_arm::setFloatRegister(int, unw_fpreg_t)",
        "external/libunwind_llvm/src/Registers.hpp",
        1700,
        "Unknown ARM float register");
    if ( !*(_BYTE *)(a1 + 73) )
    {
      *(_BYTE *)(a1 + 73) = 1;
      v9 = (_QWORD *)(a1 + 80);
      if ( *(_BYTE *)(a1 + 72) )
        sub_3E58(v9);
      else
        sub_3E50(v9);
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 1964) = a4;
    LOWORD(v11) = -1968;
  }
  HIWORD(v11) = -1;
  *(_DWORD *)(result + v11) = a3;
  return result;
}

//----- (000042E4) --------------------------------------------------------
bool __fastcall sub_42E4(_DWORD *a1)
{
  _BOOL4 result; // r0
  __int64 v3; // kr00_8
  int v4; // r0

  if ( *((_BYTE *)a1 + 528) )
    return 0;
  result = sub_4484((int)a1);
  if ( !result )
    return result;
  (*(void (__fastcall **)(_DWORD *, int))(*a1 + 52))(a1, 1);
  if ( *((_BYTE *)a1 + 528) )
    return 0;
  if ( a1[126] )
  {
    v3 = *(_QWORD *)(*a1 + 12);
    v4 = ((int (__fastcall *)(_DWORD *, int))v3)(a1, -2);
    ((void (__fastcall *)(_DWORD *, int, int))HIDWORD(v3))(a1, -2, a1[126] + v4);
  }
  return 1;
}

//----- (00004334) --------------------------------------------------------
_DWORD *__fastcall sub_4334(int a1, _DWORD *a2)
{
  int *v2; // r0
  _DWORD *result; // r0
  int v4; // r2
  int v5; // r3
  int v6; // r4
  int v7; // r12
  int v8; // lr
  _DWORD *v9; // r1
  int v10; // r3
  int v11; // r4
  int v12; // r12
  int v13; // lr

  v2 = (int *)(a1 + 488);
  v4 = *v2;
  v5 = v2[1];
  v6 = v2[2];
  v7 = v2[3];
  v8 = v2[4];
  result = v2 + 5;
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
  a2[4] = v8;
  v9 = a2 + 5;
  v10 = result[1];
  v11 = result[2];
  v12 = result[3];
  v13 = result[4];
  *v9 = *result;
  v9[1] = v10;
  v9[2] = v11;
  v9[3] = v12;
  v9[4] = v13;
  return result;
}

//----- (0000434C) --------------------------------------------------------
int __fastcall sub_434C(int a1)
{
  int v1; // r4

  v1 = a1 + 8;
  sub_44D8(a1 + 8);
  return sub_4CFC(v1);
}

//----- (00004362) --------------------------------------------------------
int __fastcall sub_4362(int a1)
{
  return *(unsigned __int8 *)(a1 + 529);
}

//----- (00004368) --------------------------------------------------------
int __fastcall sub_4368(int a1, int a2, int a3, _DWORD *a4)
{
  int v7; // r7
  char v9[8]; // [sp+8h] [bp-28h] BYREF
  const char *v10; // [sp+10h] [bp-20h]
  int v11; // [sp+14h] [bp-1Ch]

  v7 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 12))(a1, -1);
  if ( !dladdr(v7, v9) || !v10 )
    return 0;
  _snprintf_chk(a2, a3, 0, -1, "%s", v10);
  *a4 = v7 - v11;
  return 1;
}
// 1580: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 1730: using guessed type int __fastcall dladdr(_DWORD, _DWORD);
// 4368: using guessed type char var_28[8];

//----- (000043D8) --------------------------------------------------------
int __fastcall sub_43D8(int *a1, int a2)
{
  int v4; // r5
  int v6[2]; // [sp+0h] [bp-20h] BYREF
  int v7[6]; // [sp+8h] [bp-18h] BYREF

  v4 = (*(int (__fastcall **)(int *, int))(*a1 + 12))(a1, -1) & 0xFFFFFFFE;
  v7[0] = 0;
  if ( a2 )
    --v4;
  v6[0] = _gnu_Unwind_Find_exidx(v4, v7);
  v6[1] = v7[0];
  if ( !v6[0] || !v7[0] || !sub_4530(a1, v4, v6) )
    *((_BYTE *)a1 + 528) = 1;
  return _stack_chk_guard - v7[1];
}
// 173C: using guessed type int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD);

//----- (0000444E) --------------------------------------------------------
int __fastcall sub_444E(int result)
{
  *(_BYTE *)(result + 72) = 1;
  return result;
}

//----- (00004458) --------------------------------------------------------
void __fastcall __noreturn sub_4458(const char *a1, const char *a2, int a3, const char *a4)
{
  fprintf(stderr, "libunwind: %s %s:%d - %s\n", a1, a2, a3, a4);
  abort();
}

//----- (00004484) --------------------------------------------------------
bool __fastcall sub_4484(int a1)
{
  unsigned int *v2; // r0
  unsigned int v4; // [sp+4h] [bp-1Ch] BYREF
  unsigned int v5; // [sp+8h] [bp-18h] BYREF

  v4 = 0;
  v5 = 0;
  v2 = sub_35B4(*(unsigned int **)(a1 + 520), (int *)&v4, (int *)&v5);
  return sub_3608(a1, (int)v2, v4, v5) == 8;
}

//----- (000044D8) --------------------------------------------------------
_DWORD *__fastcall sub_44D8(int a1)
{
  int v2; // r0
  _DWORD *result; // r0

  if ( *(_BYTE *)(a1 + 65) )
  {
    if ( *(_BYTE *)(a1 + 64) )
      sub_4B7C();
    else
      sub_4B74();
  }
  if ( (unsigned __int8)*(_WORD *)(a1 + 66) )
  {
    sub_4B84();
    v2 = *(unsigned __int8 *)(a1 + 67);
  }
  else
  {
    v2 = HIBYTE(*(unsigned __int16 *)(a1 + 66));
  }
  if ( v2 )
    sub_4B8C((int *)(a1 + 336));
  result = (_DWORD *)*(unsigned __int8 *)(a1 + 68);
  if ( *(_BYTE *)(a1 + 68) )
    return sub_4D0C((int *)(a1 + 464));
  return result;
}

//----- (00004530) --------------------------------------------------------
int __fastcall sub_4530(int *a1, int a2, _DWORD *a3)
{
  int v4; // r5
  int v5; // r6
  char *v6; // r5
  int *v7; // r0
  int v8; // r3
  int v9; // r7
  int *v10; // r6
  int (__fastcall *v11)(int, int, int); // lr
  int v12; // r12
  int v13; // r9
  int v14; // r6
  int v15; // r6
  unsigned int v16; // r2
  int v18[3]; // [sp+14h] [bp-34h] BYREF
  int v19; // [sp+20h] [bp-28h] BYREF

  v4 = 0;
  v19 = a2;
  v5 = a3[1];
  sub_46D4(v18, 0, a1[1], a3, v5, a1[1], (int)a3, &v19);
  if ( !v18[0] || v18[0] == v5 )
    return v4;
  v6 = (char *)(*(_DWORD *)v18[2] + 8 * v18[0]);
  v7 = (int *)(v6 - 4);
  v8 = *(_DWORD *)v6;
  if ( v6 == byte_4 )
    return 0;
  v9 = *v7;
  if ( *v7 == 1 )
    return 0;
  if ( v9 < 0 )
  {
    v12 = 1;
    goto LABEL_11;
  }
  v10 = (int *)((char *)v7 + (v9 | (2 * v9) & 0x80000000));
  v9 = *v10;
  if ( *v10 <= -1 )
  {
    v12 = 0;
    v7 = v10;
LABEL_11:
    v14 = HIBYTE(v9) & 0xF;
    if ( v14 == 2 )
    {
      v11 = sub_3B94;
      v15 = 1;
    }
    else
    {
      if ( v14 != 1 )
      {
        if ( v14 )
          sub_4458(
            "bool libunwind::UnwindCursor<libunwind::LocalAddressSpace, libunwind::Registers_arm>::getInfoFromEHABISectio"
            "n(pint_t, const libunwind::UnwindInfoSections &) [A = libunwind::LocalAddressSpace, R = libunwind::Registers_arm]",
            "external/libunwind_llvm/src/UnwindCursor.hpp",
            776,
            "unknown personality routine");
        v13 = (int)(v7 + 1);
        if ( v12 )
          v13 = 0;
        v11 = sub_3B28;
        goto LABEL_17;
      }
      v11 = sub_3B8C;
      v15 = 0;
    }
    if ( ((BYTE2(v9) != 0) & (unsigned __int8)v12) == 1 )
      sub_4458(
        "bool libunwind::UnwindCursor<libunwind::LocalAddressSpace, libunwind::Registers_arm>::getInfoFromEHABISection(pi"
        "nt_t, const libunwind::UnwindInfoSections &) [A = libunwind::LocalAddressSpace, R = libunwind::Registers_arm]",
        "external/libunwind_llvm/src/UnwindCursor.hpp",
        783,
        "index inlined table detected but pr function requires extra words");
    v13 = (int)&v7[BYTE2(v9) + 1];
    goto LABEL_22;
  }
  v11 = (int (__fastcall *)(int, int, int))((char *)v10 + ((2 * v9) & 0x80000000 | v9));
  v12 = 0;
  v13 = (int)&v10[HIBYTE(v10[1]) + 2];
  v7 = v10;
LABEL_17:
  v15 = 0;
LABEL_22:
  v16 = (2 * *((_DWORD *)v6 - 2)) & 0x80000000 | *((_DWORD *)v6 - 2);
  a1[130] = (int)v7;
  a1[122] = (int)&v6[v16 - 8];
  a1[123] = (int)&v6[v8 | (2 * v8) & 0x80000000];
  a1[124] = v13;
  a1[125] = (int)v11;
  if ( v15 )
    v15 = 2;
  if ( v12 )
    v15 = 1;
  v4 = 1;
  a1[127] = v15;
  return v4;
}

//----- (000046D4) --------------------------------------------------------
_DWORD *__fastcall sub_46D4(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, _DWORD *a8)
{
  unsigned int v8; // r4
  unsigned int v9; // r5
  int v10; // r6

  v8 = a5 - a2;
  while ( 1 )
  {
    v9 = v8;
    if ( !v8 )
      break;
    v10 = a2 + (v8 >> 1);
    v8 >>= 1;
    if ( *a8 >= *a4 + 8 * v10 + ((2 * *(_DWORD *)(*a4 + 8 * v10)) & 0x80000000 | *(_DWORD *)(*a4 + 8 * v10)) )
    {
      v8 = v9 - 1 - v8;
      a2 = v10 + 1;
    }
  }
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  return a1 + 3;
}

//----- (00004B60) --------------------------------------------------------
int __fastcall sub_4B60(int a1)
{
  return (*(int (__fastcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(a1 + 60))(
           *(_DWORD *)a1,
           *(_DWORD *)(a1 + 4),
           *(_DWORD *)(a1 + 8),
           *(_DWORD *)(a1 + 12));
}

//----- (00004B74) --------------------------------------------------------
void sub_4B74()
{
  ;
}

//----- (00004B7C) --------------------------------------------------------
void sub_4B7C()
{
  ;
}

//----- (00004B84) --------------------------------------------------------
void sub_4B84()
{
  ;
}

//----- (00004B8C) --------------------------------------------------------
_DWORD *__fastcall sub_4B8C(int *a1)
{
  int *v5; // r0
  _DWORD *result; // r0

  _T1 = *a1;
  v5 = a1 + 2;
  __asm { LDCL            p1, c0, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c1, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c2, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c3, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c4, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c5, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c6, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c7, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c8, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c9, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c10, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c11, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c12, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c13, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c14, [R0],#8 }
  _T1 = *v5;
  result = v5 + 2;
  __asm { LDCL            p1, c15, [R0],#8 }
  return result;
}

//----- (00004BD0) --------------------------------------------------------
_DWORD *__fastcall sub_4BD0(int *a1)
{
  int *v5; // r0
  _DWORD *result; // r0

  _T1 = *a1;
  v5 = a1 + 1;
  __asm { LDC2            p1, c8, [R0],#4 }
  _T1 = *v5++;
  __asm { LDC2            p1, c9, [R0],#4 }
  _T1 = *v5++;
  __asm { LDC2            p1, c10, [R0],#4 }
  _T1 = *v5;
  result = v5 + 1;
  __asm { LDC2            p1, c11, [R0],#4 }
  return result;
}

//----- (00004CAC) --------------------------------------------------------
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00004CBC) --------------------------------------------------------
// attributes: thunk
void __fastcall j_free(void *ptr)
{
  free(ptr);
}

//----- (00004CCC) --------------------------------------------------------
// attributes: thunk
int __fastcall j_j_mixer_ctl_set_value(int **a1, unsigned int a2, int a3)
{
  return j_mixer_ctl_set_value(a1, a2, a3);
}

//----- (00004CDC) --------------------------------------------------------
// attributes: thunk
int __fastcall j_j_pcm_mmap_avail(int a1)
{
  return j_pcm_mmap_avail(a1);
}

//----- (00004CEC) --------------------------------------------------------
// attributes: thunk
int __fastcall j_j_pcm_mmap_transfer(int a1, int a2, unsigned int a3)
{
  return j_pcm_mmap_transfer(a1, a2, a3);
}

//----- (00004CFC) --------------------------------------------------------
// attributes: thunk
int __fastcall sub_4CFC(int a1)
{
  return sub_4B60(a1);
}

//----- (00004D0C) --------------------------------------------------------
// attributes: thunk
_DWORD *__fastcall sub_4D0C(int *a1)
{
  return sub_4BD0(a1);
}

// nfuncs=207 queued=143 decompiled=143 lumina nreq=0 worse=0 better=0
// ALL OK, 143 function(s) have been successfully decompiled

