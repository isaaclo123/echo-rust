/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

//-------------------------------------------------------------------------
// Function declarations

void sub_840();
// int __fastcall _cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void
// *lpdso_handle); int __fastcall _register_atfork(_DWORD, _DWORD, _DWORD,
// _DWORD); weak int strcmp(const char *s1, const char *s2); int atoi(const char
// *nptr); int printf(const char *format, ...); int __fastcall
// pcm_params_get(_DWORD, _DWORD, _DWORD); weak int __fastcall
// pcm_params_get_mask(_DWORD, _DWORD); weak int putchar(int c); int __fastcall
// pcm_params_get_min(_DWORD, _DWORD); weak int __fastcall
// pcm_params_get_max(_DWORD, _DWORD); weak int __fastcall
// pcm_params_free(_DWORD); weak int puts(const char *s); int fprintf(FILE
// *stream, const char *format, ...); void abort(void); void __fastcall
// _aeabi_memcpy(void *, const void *, size_t); idb void __fastcall
// _aeabi_memclr8(void *, size_t); idb int __fastcall dladdr(_DWORD, _DWORD);
// weak int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// weak int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD); weak
int (*__fastcall sub_9C8(int (*result)(void)))(void);
int __fastcall sub_9F4(void *a1);
int __fastcall sub_A40(int a1, int a2, int a3);
int __fastcall main(int argc, const char **argv, const char **envp);
unsigned int *__fastcall sub_D60(unsigned int *result, int *a2, int *a3);
int __fastcall sub_DB4(int a1, int a2, unsigned int a3, unsigned int a4);
int __fastcall sub_1064(int a1, int a2, unsigned int a3, int a4, _QWORD *a5);
int __fastcall sub_10F8(int a1, int a2, unsigned int a3, int a4, int *a5);
int __fastcall sub_1194(int a1, int a2, unsigned int a3, int a4);
int __fastcall sub_1348(int *a1, int a2, int a3, int a4);
int __fastcall sub_13F4(const void *a1, int *a2, char a3);
void __fastcall __noreturn sub_14E4(int *a1, int a2, int a3, int a4);
void __fastcall __noreturn sub_1518(const char *a1, int a2, const char *a3);
int __fastcall sub_154C(int a1);
int __fastcall sub_1588(int a1);
int __fastcall sub_15D0(int a1, int a2);
int __fastcall sub_15E4(_DWORD *a1, int a2, int a3, int a4, int a5);
_QWORD *__fastcall sub_15FC(_QWORD *result);
_QWORD *__fastcall sub_1604(_QWORD *result);
_QWORD *__fastcall sub_160C(_QWORD *result);
void sub_1614();
void sub_1658();
int __fastcall sub_166C(int a1, const void *a2);
int __fastcall sub_16B0(int a1, int a2, _DWORD *a3);
int __fastcall sub_16DE(int a1, int a2, int a3);
int __fastcall sub_1722(int a1, int a2, _QWORD *a3);
int __fastcall sub_1752(int a1, int a2, int a3, int a4);
int __fastcall sub_178A(int a1);
int __fastcall sub_1790(int a1, int a2);
int __fastcall sub_17AE(int a1);
int __fastcall sub_17C0(int a1);
bool __fastcall sub_17C6(int a1, int a2);
int __fastcall sub_17E8(int a1, int a2);
int __fastcall sub_1874(int result, int a2, int a3);
bool __fastcall sub_1900(int a1, int a2);
__int64 __fastcall sub_1920(int a1, int a2);
int __fastcall sub_19C4(int a1, int a2, int a3, int a4);
bool __fastcall sub_1A90(_DWORD *a1);
_DWORD *__fastcall sub_1AE0(int a1, _DWORD *a2);
int __fastcall sub_1AF8(int a1);
int __fastcall sub_1B0E(int a1);
int __fastcall sub_1B14(int a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_1B84(int *a1, int a2);
int __fastcall sub_1BFA(int result);
void __fastcall __noreturn sub_1C04(const char *a1, const char *a2, int a3,
                                    const char *a4);
bool __fastcall sub_1C30(int a1);
_DWORD *__fastcall sub_1C84(int a1);
int __fastcall sub_1CDC(int *a1, int a2, _DWORD *a3);
_DWORD *__fastcall sub_1E80(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5,
                            int a6, int a7, _DWORD *a8);
int __fastcall sub_230C(int a1);
void sub_2320();
void sub_2328();
void sub_2330();
_DWORD *__fastcall sub_2338(int *a1);
_DWORD *__fastcall sub_237C(int *a1);
int __fastcall sub_2390(int a1);
_DWORD *__fastcall sub_23A0(int *a1);

//-------------------------------------------------------------------------
// Data declarations

char byte_4 = '\x01';                   // weak
char byte_12D5[3] = {'F', '\x11', 'F'}; // weak
char byte_1339[3] = {'F', '\x11', 'F'}; // weak
char byte_1341[3] = {'F', '\x11', 'F'}; // weak
char *off_4D54[25] = {"S8",
                      "U8",
                      "S16_LE",
                      "S16_BE",
                      "U16_LE",
                      "U16_BE",
                      "S24_LE",
                      "S24_BE",
                      "U24_LE",
                      "U24_BE",
                      "S32_LE",
                      "S32_BE",
                      "U32_LE",
                      "U32_BE",
                      "FLOAT_LE",
                      "FLOAT_BE",
                      "FLOAT64_LE",
                      "FLOAT64_BE",
                      "IEC958_SUBFRAME_LE",
                      "IEC958_SUBFRAME_BE",
                      "MU_LAW",
                      "A_LAW",
                      "IMA_ADPCM",
                      "MPEG",
                      "GSM"};    // weak
void *off_4E0C = (void *)0x14E1; // weak
_UNKNOWN unk_5000;               // weak
_UNKNOWN unk_5004;               // weak
// extern struct _IO_FILE *stderr;
// extern _UNKNOWN _stack_chk_guard; weak

//----- (00000840) --------------------------------------------------------
void sub_840() { JUMPOUT(0); }
// 84C: control flows out of bounds to 0

//----- (000009C8) --------------------------------------------------------
int (*__fastcall sub_9C8(int (*result)(void)))(void) {
  if (result)
    return (int (*)(void))result();
  return result;
}

//----- (000009F4) --------------------------------------------------------
int __fastcall sub_9F4(void *a1) {
  return _cxa_atexit((void(__fastcall *)(void *))sub_9C8, a1, &unk_5000);
}

//----- (00000A40) --------------------------------------------------------
int __fastcall sub_A40(int a1, int a2, int a3) {
  return _register_atfork(a1, a2, a3, &unk_5000);
}
// 86C: using guessed type int __fastcall _register_atfork(_DWORD, _DWORD,
// _DWORD, _DWORD);

//----- (00000A88) --------------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp) {
  const char **v3;  // r6
  const char *v4;   // r7
  int v5;           // r4
  int v6;           // r5
  const char *v7;   // t1
  const char *v8;   // t1
  int v9;           // r6
  int i;            // r7
  const char *v11;  // r1
  int v12;          // r2
  int v13;          // r0
  int v14;          // r5
  _DWORD *mask;     // r0
  _DWORD *v16;      // r0
  _DWORD *v17;      // r8
  int v18;          // r0
  unsigned int v19; // r4
  int v20;          // r7
  char **v21;       // r10
  int v22;          // r11
  const char **v23; // r9
  const char *v24;  // r6
  int v25;          // r5
  int v26;          // r4
  _DWORD *v27;      // r0
  int min;          // r6
  int max;          // r0
  int v30;          // r6
  int v31;          // r0
  int v32;          // r6
  int v33;          // r0
  int v34;          // r6
  int v35;          // r0
  int v36;          // r6
  int v37;          // r0
  int v39;          // [sp+0h] [bp-38h]
  int v40;          // [sp+4h] [bp-34h]
  int v41;          // [sp+8h] [bp-30h]
  int v42;          // [sp+Ch] [bp-2Ch]
  unsigned int v43; // [sp+10h] [bp-28h]

  if (argc <= 2) {
    fprintf(stderr, "Usage: %s -D card -d device\n", *argv);
    return 1;
  } else {
    v3 = argv + 1;
    v4 = argv[1];
    v5 = 0;
    if (v4) {
      v6 = 0;
      do {
        if (!strcmp(v4, "-D")) {
          v7 = v3[1];
          ++v3;
          v4 = v7;
          if (v7)
            v6 = atoi(v4);
          else
            v4 = 0;
        }
        if (!strcmp(v4, "-d")) {
          v8 = v3[1];
          ++v3;
          v4 = v8;
          if (v8)
            v5 = atoi(v4);
          else
            v4 = 0;
        }
        if (v4)
          ++v3;
        v4 = *v3;
      } while (*v3);
    } else {
      v6 = 0;
    }
    v9 = v5;
    v41 = v6;
    v39 = v5;
    printf("Info for card %d, device %d:\n", v6, v5);
    for (i = 0; i != 2; ++i) {
      v11 = "in";
      if (!i)
        v11 = "out";
      printf("\nPCM %s:\n", v11);
      v12 = i;
      if (i)
        v12 = 0x10000000;
      v13 = pcm_params_get(v41, v9, v12);
      v14 = v13;
      if (v13) {
        mask = (_DWORD *)pcm_params_get_mask(v13, 0);
        if (mask)
          printf("      Access:\t%#08x\n", *mask);
        v42 = v14;
        v16 = (_DWORD *)pcm_params_get_mask(v14, 1);
        v17 = v16;
        if (v16) {
          v40 = i;
          printf("   Format[0]:\t%#08x\n", *v16);
          printf("   Format[1]:\t%#08x\n", v17[1]);
          v18 = 0;
          v19 = -25;
          v20 = 0;
          v21 = off_4D54;
          do {
            v22 = 0;
            v23 = (const char **)v21;
            v43 = v19;
            do {
              if ((v17[v20] & (1 << v22)) != 0 && v19 + 25 <= 0x2B &&
                  v19 >= 6) {
                v24 = *v23;
                v25 = v18 + 1;
                if (v18)
                  printf(", ");
                else
                  printf(" Format Name:\t");
                printf("%s", v24);
                v18 = v25;
              }
              ++v22;
              ++v23;
              ++v19;
            } while (v22 != 32);
            ++v20;
            v21 += 32;
            v19 = v43 + 32;
          } while (v20 != 2);
          v9 = v39;
          i = v40;
          if (v18)
            putchar(10);
        }
        v26 = v9;
        v27 = (_DWORD *)pcm_params_get_mask(v42, 2);
        if (v27)
          printf("   Subformat:\t%#08x\n", *v27);
        min = pcm_params_get_min(v42, 6);
        max = pcm_params_get_max(v42, 6);
        printf("        Rate:\tmin=%uHz\tmax=%uHz\n", min, max);
        v30 = pcm_params_get_min(v42, 5);
        v31 = pcm_params_get_max(v42, 5);
        printf("    Channels:\tmin=%u\t\tmax=%u\n", v30, v31);
        v32 = pcm_params_get_min(v42, 3);
        v33 = pcm_params_get_max(v42, 3);
        printf(" Sample bits:\tmin=%u\t\tmax=%u\n", v32, v33);
        v34 = pcm_params_get_min(v42, 8);
        v35 = pcm_params_get_max(v42, 8);
        printf(" Period size:\tmin=%u\t\tmax=%u\n", v34, v35);
        v36 = pcm_params_get_min(v42, 10);
        v37 = pcm_params_get_max(v42, 10);
        printf("Period count:\tmin=%u\t\tmax=%u\n", v36, v37);
        pcm_params_free(v42);
        v9 = v26;
      } else {
        puts("Device does not exist.");
      }
    }
    return 0;
  }
}
// 89C: using guessed type int __fastcall pcm_params_get(_DWORD, _DWORD,
// _DWORD); 8A8: using guessed type int __fastcall pcm_params_get_mask(_DWORD,
// _DWORD); 8C0: using guessed type int __fastcall pcm_params_get_min(_DWORD,
// _DWORD); 8CC: using guessed type int __fastcall pcm_params_get_max(_DWORD,
// _DWORD); 8D8: using guessed type int __fastcall pcm_params_free(_DWORD);
// 4D54: using guessed type char *off_4D54[25];

//----- (00000D60) --------------------------------------------------------
unsigned int *__fastcall sub_D60(unsigned int *result, int *a2, int *a3) {
  unsigned int v3; // r3
  unsigned int v4; // t1
  int v5;          // r12
  bool v6;         // zf
  int v7;          // r3
  int v8;          // r12

  v3 = *result;
  if ((*result & 0x80000000) == 0) {
    *a2 = 1;
    v4 = result[1];
    ++result;
    *a3 = 4 * HIBYTE(v4) + 4;
    return result;
  }
  v5 = HIBYTE(v3) & 0xF;
  if (v5) {
    v6 = v5 == 3;
    if (v5 != 3)
      v6 = v5 == 1;
    if (!v6)
      return 0;
    v7 = 4 * BYTE2(v3) + 4;
    v8 = 2;
  } else {
    v8 = 1;
    v7 = 4;
  }
  *a3 = v7;
  *a2 = v8;
  return result;
}

//----- (00000DB4) --------------------------------------------------------
int __fastcall sub_DB4(int a1, int a2, unsigned int a3, unsigned int a4) {
  unsigned int v6;  // r11
  unsigned int v8;  // r7
  int v9;           // r10
  int v10;          // r2
  unsigned int v11; // r1
  int result;       // r0
  int v13;          // r3
  int v14;          // r2
  int v15;          // r0
  int v16;          // r1
  int v17;          // r2
  int v18;          // r1
  int v19;          // r6
  int v20;          // r2
  int v21;          // r0
  int v22;          // r1
  int v23;          // r3
  int v24;          // r0
  int v25;          // r0
  unsigned int v32; // r1
  unsigned int v33; // r0
  int v34;          // r1
  unsigned int v35; // r0
  int v36;          // [sp+0h] [bp-30h]
  int v37;          // [sp+4h] [bp-2Ch] BYREF

  v6 = a3;
  if (a3 >= a4) {
  LABEL_54:
    sub_16B0(a1, 14, &v37);
    sub_16DE(a1, 15, v37);
    return 8;
  }
  v36 = 0;
  do {
    v8 = v6 + 1;
    v9 = *(unsigned __int8 *)(a2 + (v6 ^ 3));
    if ((v9 & 0x80) == 0) {
      sub_16B0(a1, 13, &v37);
      if ((v9 & 0x40) != 0)
        v10 = -4 - (unsigned __int8)(4 * v9) + v37;
      else
        v10 = 4 * v9 + v37 + 4;
    LABEL_12:
      v37 = v10;
    LABEL_13:
      sub_16DE(a1, 13, v10);
    LABEL_36:
      v6 = v8;
      continue;
    }
    v11 = v9 & 0xF0;
    result = 9;
    if (v11 > 0xAF) {
      if (v11 == 176) {
        result = 9;
        v18 = 0;
        v19 = 0;
        switch (*(_BYTE *)(a2 + (v6 ^ 3))) {
        case 0xB0:
          goto LABEL_53;
        case 0xB1:
          if (v8 >= a4)
            return 9;
          v20 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
          result = 9;
          if (!*(_BYTE *)(a2 + (v8 ^ 3)) || (v20 & 0xF0) != 0)
            return result;
          v21 = a1;
          v22 = 0;
          v23 = 0;
          goto LABEL_48;
        case 0xB2:
          break;
        case 0xB3:
          v23 = 1;
          v25 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
          _R1 = v25 << 12;
          __asm { UXTB16.W        R1, R1 }
          v20 = ((v25 & 0xF) + 1) | _R1;
          v21 = a1;
          v22 = 1;
          goto LABEL_48;
        case 0xB4:
        case 0xB5:
        case 0xB6:
        case 0xB7:
          return result;
        default:
          v16 = 1;
          v13 = 1;
          v14 = ((v9 & 7) + 1) | 0x80000;
          v15 = a1;
          goto LABEL_35;
        }
        while (v8 < a4) {
          v24 = v8++ ^ 3;
          LOBYTE(v24) = *(_BYTE *)(a2 + v24);
          v19 |= (v24 & 0x7F) << v18;
          v18 += 7;
          if ((v24 & 0x80) == 0) {
            sub_16B0(a1, 13, &v37);
            v10 = v37 + 4 * v19 + 516;
            goto LABEL_12;
          }
        }
        return 9;
      }
      if (v11 != 192) {
        if (v11 != 208)
          return result;
        if ((v9 & 8) != 0)
          return 9;
        v16 = 1;
        v14 = ((v9 & 7) + 1) | 0x80000;
        v15 = a1;
      LABEL_34:
        v13 = 5;
        goto LABEL_35;
      }
      switch (*(_BYTE *)(a2 + (v6 ^ 3))) {
      case 0xC0:
      case 0xC1:
      case 0xC2:
      case 0xC3:
      case 0xC4:
      case 0xC5:
        v16 = 3;
        v14 = ((v9 & 7) + 1) | 0xA0000;
        v15 = a1;
        goto LABEL_34;
      case 0xC6:
        v35 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
        if ((v35 & 0xF) + (v35 >> 4) > 0xF)
          return 9;
        v20 = ((v35 & 0xF) + 1) | (v35 >> 4 << 16);
        v21 = a1;
        v22 = 3;
        break;
      case 0xC7:
        if (!*(_BYTE *)(a2 + (v8 ^ 3)) ||
            *(unsigned __int8 *)(a2 + (v8 ^ 3)) >= 0x10u)
          return 9;
        goto LABEL_49;
      case 0xC8:
      case 0xC9:
        v32 = *(unsigned __int8 *)(a2 + (v8 ^ 3));
        v33 = v32 >> 4;
        if (v9 == 200)
          v33 = (v32 >> 4) | 0x10;
        v34 = v32 & 0xF;
        if (v33 + v34 > 0x1F)
          return 9;
        v20 = (v34 + 1) | (v33 << 16);
        v21 = a1;
        v22 = 1;
        break;
      default:
        return 9;
      }
      v23 = 5;
    LABEL_48:
      sub_1194(v21, v22, v20, v23);
    } else {
      if (v11 != 128) {
        if (v11 == 144) {
          if ((v9 & 0xD | 2) == 15)
            return 9;
          sub_16B0(a1, v9 & 0xF, &v37);
          v10 = v37;
          goto LABEL_13;
        }
        if (v11 != 160)
          return result;
        v13 = 0;
        v14 = ((16 << ((v9 & 7) + 1)) - 16) | (v9 << 11) & 0x4000;
        v15 = a1;
        v16 = 0;
      LABEL_35:
        sub_1194(v15, v16, v14, v13);
        goto LABEL_36;
      }
      if (v8 >= a4)
        return 9;
      v17 = (unsigned __int16)((_WORD)v9 << 12) |
            (16 * *(unsigned __int8 *)(a2 + (v8 ^ 3)));
      if (!v17)
        return 9;
      sub_1194(a1, 0, v17, 0);
      v36 |= (unsigned __int16)(((_WORD)v9 << 12) & 0x8000) >> 15;
    }
  LABEL_49:
    v6 += 2;
  } while (v6 < a4);
LABEL_53:
  if ((v36 & 1) == 0)
    goto LABEL_54;
  return 8;
}

//----- (00001064) --------------------------------------------------------
int __fastcall sub_1064(int a1, int a2, unsigned int a3, int a4, _QWORD *a5) {
  int result; // r0
  int v8;     // r0
  int v9;     // r1
  int v10;    // r1

  switch (a2) {
  case 0:
    result = 2;
    if (a3 > 0xF || a4)
      return result;
    v8 = a1;
    v9 = a3;
    goto LABEL_11;
  case 1:
    if (a4 == 5) {
      if (a3 <= 0x1F)
        goto LABEL_19;
      return 2;
    }
    if (a4 != 1 || a3 > 0xF)
      return 2;
    sub_17C0(a1);
  LABEL_19:
    v10 = a3 + 256;
  LABEL_20:
    result = sub_1722(a1, v10, a5);
  LABEL_21:
    if (result)
      return 2;
    return result;
  case 3:
    result = 2;
    if (a3 > 0x1F || a4 != 5)
      return result;
    v10 = a3 + 112;
    goto LABEL_20;
  case 4:
    result = 2;
    if (a3 > 3 || a4)
      return result;
    v9 = a3 + 192;
    v8 = a1;
  LABEL_11:
    result = sub_16B0(v8, v9, a5);
    goto LABEL_21;
  default:
    sub_1518("_Unwind_VRS_Result _Unwind_VRS_Get_Internal(_Unwind_Context *, "
             "_Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataR"
             "epresentation, void *)",
             885, "unsupported register class");
  }
}

//----- (000010F8) --------------------------------------------------------
int __fastcall sub_10F8(int a1, int a2, unsigned int a3, int a4, int *a5) {
  int result;  // r0
  int v8;      // r2
  int v9;      // r0
  int v10;     // r1
  __int64 v11; // r2
  int v12;     // r1

  switch (a2) {
  case 0:
    result = 2;
    if (a3 > 0xF || a4)
      return result;
    v8 = *a5;
    v9 = a1;
    v10 = a3;
    goto LABEL_11;
  case 1:
    if (a4 == 5) {
      if (a3 <= 0x1F)
        goto LABEL_19;
      return 2;
    }
    if (a4 != 1 || a3 > 0xF)
      return 2;
    sub_17C0(a1);
  LABEL_19:
    v11 = *(_QWORD *)a5;
    v12 = a3 + 256;
  LABEL_20:
    result = sub_1752(a1, v12, v11, SHIDWORD(v11));
  LABEL_21:
    if (result)
      return 2;
    return result;
  case 3:
    result = 2;
    if (a3 > 0x1F || a4 != 5)
      return result;
    v11 = *(_QWORD *)a5;
    v12 = a3 + 112;
    goto LABEL_20;
  case 4:
    result = 2;
    if (a3 > 3 || a4)
      return result;
    v8 = *a5;
    v10 = a3 + 192;
    v9 = a1;
  LABEL_11:
    result = sub_16DE(v9, v10, v8);
    goto LABEL_21;
  default:
    sub_1518("_Unwind_VRS_Result _Unwind_VRS_Set(_Unwind_Context *, "
             "_Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataRepresentation, "
             "void *)",
             837, "unsupported register class");
  }
}

//----- (00001194) --------------------------------------------------------
int __fastcall sub_1194(int a1, int a2, unsigned int a3, int a4) {
  char v8;          // r4
  unsigned int i;   // r7
  int *v10;         // r0
  int result;       // r0
  unsigned int v12; // r4
  unsigned int v13; // r6
  int *v14;         // r0
  int v15;          // r2
  int v16;          // r0
  int v17;          // r2
  int v18[2];       // [sp+8h] [bp-30h] BYREF
  int *v19;         // [sp+10h] [bp-28h] BYREF

  switch (a2) {
  case 0:
  case 4:
    if (a4 || sub_16B0(a1, 13, v18))
      return 2;
    v8 = 0;
    for (i = 0; i < 0x10; ++i) {
      if (((1 << i) & a3) != 0) {
        v10 = (int *)v18[0];
        v18[0] += 4;
        v19 = (int *)*v10;
        if (sub_10F8(a1, a2, i, 0, (int *)&v19))
          return 2;
        v8 |= a2 == 0 && i == 13;
      }
    }
    if ((v8 & 1) != 0)
      return 0;
    v17 = v18[0];
    goto LABEL_22;
  case 1:
  case 3:
    if ((a4 | 4) != 5 || sub_16B0(a1, 13, &v19))
      return 2;
    if (!(_WORD)a3)
      goto LABEL_17;
    v12 = HIWORD(a3);
    v13 = HIWORD(a3) + (unsigned __int16)a3;
    break;
  default:
    sub_1518("_Unwind_VRS_Result _Unwind_VRS_Pop(_Unwind_Context *, "
             "_Unwind_VRS_RegClass, uint32_t, _Unwind_VRS_DataRepresentation)",
             971, "unsupported register class");
  }
  do {
    v14 = v19++;
    v15 = *v14;
    v19 = v14 + 2;
    v16 = v14[1];
    v18[0] = v15;
    v18[1] = v16;
    if (sub_10F8(a1, a2, v12, a4, v18))
      return 2;
    ++v12;
  } while (v12 < v13);
LABEL_17:
  if (a4 == 1)
    v17 = (int)++v19;
  else
    v17 = (int)v19;
LABEL_22:
  result = sub_16DE(a1, 13, v17);
  if (result)
    return 2;
  return result;
}

//----- (00001348) --------------------------------------------------------
int __fastcall sub_1348(int *a1, int a2, int a3, int a4) {
  int v5;                                       // r5
  int(__fastcall * v6)(_DWORD, int *, char *);  // r3
  int v7;                                       // r0
  int v9[3];                                    // [sp+0h] [bp-8A0h] BYREF
  int(__fastcall * v10)(_DWORD, int *, char *); // [sp+Ch] [bp-894h]
  int v11;                                      // [sp+14h] [bp-88Ch]
  int v12;                                      // [sp+20h] [bp-880h]
  _DWORD v13[256];                              // [sp+28h] [bp-878h] BYREF
  char v14[1120];                               // [sp+428h] [bp-478h] BYREF

  sub_15E4(v13, a2, a3, a4, v9[0]);
  a1[3] = 0;
  sub_166C((int)v14, v13);
  if (sub_1790((int)v14, (int)v9))
    return 3;
  v5 = 3;
  while (1) {
    v6 = v10;
    if (v10) {
      a1[18] = v9[0];
      a1[19] = v12;
      a1[20] = v11;
      v7 = v6(0, a1, v14);
      if (v7 != 8)
        break;
    }
    if (sub_1790((int)v14, (int)v9))
      return 3;
  }
  if (v7 == 6) {
    sub_13F4(v13, a1, 0);
    return 2;
  } else if (v7 == 9) {
    return 9;
  }
  return v5;
}
// 1348: using guessed type _DWORD var_878[256];

//----- (000013F4) --------------------------------------------------------
int __fastcall sub_13F4(const void *a1, int *a2, char a3) {
  int i;                                     // r6
  int v6;                                    // r7
  int(__fastcall * v7)(int, int *, char *);  // r3
  int v8;                                    // r0
  int v10;                                   // [sp+0h] [bp-4B8h] BYREF
  int v11[3];                                // [sp+4h] [bp-4B4h] BYREF
  int(__fastcall * v12)(int, int *, char *); // [sp+10h] [bp-4A8h]
  int v13;                                   // [sp+18h] [bp-4A0h]
  int v14;                                   // [sp+24h] [bp-494h]
  int v15;                                   // [sp+2Ch] [bp-48Ch] BYREF
  char v16[1124];                            // [sp+30h] [bp-488h] BYREF
  int v17;                                   // [sp+494h] [bp-24h]

  sub_166C((int)v16, a1);
  for (i = 1;; --i) {
    v6 = 1;
    if ((a3 & 1) != 0) {
      v6 = 2;
      if (!i) {
        sub_16DE((int)v16, -1, a2[4]);
        a3 = 0;
      }
    }
    sub_16B0((int)v16, -2, &v15);
    if (sub_1790((int)v16, (int)v11))
      break;
    v7 = v12;
    if (v12) {
      a2[18] = v11[0];
      a2[19] = v14;
      a2[20] = v13;
      v8 = v7(v6, a2, v16);
      if (v8 == 7) {
        sub_16B0((int)v16, -1, &v10);
        a2[4] = v10;
        sub_17AE((int)v16);
        return _stack_chk_guard - v17;
      }
      if (v8 != 8) {
        if (v8 == 9)
          abort();
        return _stack_chk_guard - v17;
      }
      if (v15 == a2[8])
        sub_1518("_Unwind_Reason_Code unwind_phase2(unw_context_t *, "
                 "_Unwind_Exception *, bool)",
                 653,
                 "during phase1 personality function said it would stop here, "
                 "but now in phase2 it did not stop here");
    }
  }
  return _stack_chk_guard - v17;
}
// 13F4: using guessed type int var_4B4[3];

//----- (000014E4) --------------------------------------------------------
void __fastcall __noreturn sub_14E4(int *a1, int a2, int a3, int a4) {
  int v5[260]; // [sp+0h] [bp-410h] BYREF

  sub_15E4(v5, a2, a3, a4, v5[0]);
  sub_13F4(v5, a1, 1);
  sub_1518("void _Unwind_Resume(_Unwind_Exception *)", 753,
           "_Unwind_Resume() can't return");
}

//----- (00001518) --------------------------------------------------------
void __fastcall __noreturn sub_1518(const char *a1, int a2, const char *a3) {
  fprintf(stderr, "libunwind: %s %s:%d - %s\n", a1,
          "external/libunwind_llvm/src/Unwind-EHABI.cpp", a2, a3);
  abort();
}

//----- (0000154C) --------------------------------------------------------
int __fastcall sub_154C(int a1) {
  bool v1;    // zf
  int result; // r0
  char v3[8]; // [sp+4h] [bp-34h] BYREF
  int v4;     // [sp+Ch] [bp-2Ch]

  v1 = sub_1790(a1, (int)v3) == 0;
  result = v4;
  if (!v1)
    return 0;
  return result;
}
// 154C: using guessed type char var_34[8];

//----- (00001588) --------------------------------------------------------
int __fastcall sub_1588(int a1) {
  bool v1;    // zf
  int result; // r0
  int v3[10]; // [sp+4h] [bp-34h] BYREF

  v1 = sub_1790(a1, (int)v3) == 0;
  result = v3[0];
  if (!v1)
    return 0;
  return result;
}
// 1588: using guessed type int var_34[10];

//----- (000015D0) --------------------------------------------------------
int __fastcall sub_15D0(int a1, int a2) {
  int v2; // r0
  int v3; // r1

  v2 = sub_178A(a2);
  v3 = 9;
  if (v2 == 1)
    return 0;
  return v3;
}

//----- (000015E4) --------------------------------------------------------
int __fastcall sub_15E4(_DWORD *a1, int a2, int a3, int a4, int a5) {
  int v5;  // r4
  int v6;  // r5
  int v7;  // r6
  int v8;  // r7
  int v9;  // r8
  int v10; // r9
  int v11; // r10
  int v12; // r11
  int v13; // r12
  int v14; // lr

  *a1 = a1;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  a1[4] = v5;
  a1[5] = v6;
  a1[6] = v7;
  a1[7] = v8;
  a1[8] = v9;
  a1[9] = v10;
  a1[10] = v11;
  a1[11] = v12;
  a1[12] = v13;
  a1[13] = &a5;
  a1[14] = v14;
  a1[15] = v14;
  return 0;
}
// 15E4: variable 'v5' is possibly undefined
// 15E4: variable 'v6' is possibly undefined
// 15E4: variable 'v7' is possibly undefined
// 15E4: variable 'v8' is possibly undefined
// 15E4: variable 'v9' is possibly undefined
// 15E4: variable 'v10' is possibly undefined
// 15E4: variable 'v11' is possibly undefined
// 15E4: variable 'v12' is possibly undefined
// 15E4: variable 'v13' is possibly undefined
// 15EC: variable 'v14' is possibly undefined

//----- (000015FC) --------------------------------------------------------
_QWORD *__fastcall sub_15FC(_QWORD *result) {
  __int64 v1;  // d0
  __int64 v2;  // d1
  __int64 v3;  // d2
  __int64 v4;  // d3
  __int64 v5;  // d4
  __int64 v6;  // d5
  __int64 v7;  // d6
  __int64 v8;  // d7
  __int64 v9;  // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// 15FC: variable 'v1' is possibly undefined
// 15FC: variable 'v2' is possibly undefined
// 15FC: variable 'v3' is possibly undefined
// 15FC: variable 'v4' is possibly undefined
// 15FC: variable 'v5' is possibly undefined
// 15FC: variable 'v6' is possibly undefined
// 15FC: variable 'v7' is possibly undefined
// 15FC: variable 'v8' is possibly undefined
// 15FC: variable 'v9' is possibly undefined
// 15FC: variable 'v10' is possibly undefined
// 15FC: variable 'v11' is possibly undefined
// 15FC: variable 'v12' is possibly undefined
// 15FC: variable 'v13' is possibly undefined
// 15FC: variable 'v14' is possibly undefined
// 15FC: variable 'v15' is possibly undefined
// 15FC: variable 'v16' is possibly undefined

//----- (00001604) --------------------------------------------------------
_QWORD *__fastcall sub_1604(_QWORD *result) {
  __int64 v1;  // d0
  __int64 v2;  // d1
  __int64 v3;  // d2
  __int64 v4;  // d3
  __int64 v5;  // d4
  __int64 v6;  // d5
  __int64 v7;  // d6
  __int64 v8;  // d7
  __int64 v9;  // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// 1604: variable 'v1' is possibly undefined
// 1604: variable 'v2' is possibly undefined
// 1604: variable 'v3' is possibly undefined
// 1604: variable 'v4' is possibly undefined
// 1604: variable 'v5' is possibly undefined
// 1604: variable 'v6' is possibly undefined
// 1604: variable 'v7' is possibly undefined
// 1604: variable 'v8' is possibly undefined
// 1604: variable 'v9' is possibly undefined
// 1604: variable 'v10' is possibly undefined
// 1604: variable 'v11' is possibly undefined
// 1604: variable 'v12' is possibly undefined
// 1604: variable 'v13' is possibly undefined
// 1604: variable 'v14' is possibly undefined
// 1604: variable 'v15' is possibly undefined
// 1604: variable 'v16' is possibly undefined

//----- (0000160C) --------------------------------------------------------
_QWORD *__fastcall sub_160C(_QWORD *result) {
  __int64 v1;  // d16
  __int64 v2;  // d17
  __int64 v3;  // d18
  __int64 v4;  // d19
  __int64 v5;  // d20
  __int64 v6;  // d21
  __int64 v7;  // d22
  __int64 v8;  // d23
  __int64 v9;  // d24
  __int64 v10; // d25
  __int64 v11; // d26
  __int64 v12; // d27
  __int64 v13; // d28
  __int64 v14; // d29
  __int64 v15; // d30
  __int64 v16; // d31

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// 160C: variable 'v1' is possibly undefined
// 160C: variable 'v2' is possibly undefined
// 160C: variable 'v3' is possibly undefined
// 160C: variable 'v4' is possibly undefined
// 160C: variable 'v5' is possibly undefined
// 160C: variable 'v6' is possibly undefined
// 160C: variable 'v7' is possibly undefined
// 160C: variable 'v8' is possibly undefined
// 160C: variable 'v9' is possibly undefined
// 160C: variable 'v10' is possibly undefined
// 160C: variable 'v11' is possibly undefined
// 160C: variable 'v12' is possibly undefined
// 160C: variable 'v13' is possibly undefined
// 160C: variable 'v14' is possibly undefined
// 160C: variable 'v15' is possibly undefined
// 160C: variable 'v16' is possibly undefined

//----- (00001614) --------------------------------------------------------
void sub_1614() {
  __asm
  {
    STCL            p1, c0, [R0],#8
    STCL            p1, c1, [R0],#8
    STCL            p1, c2, [R0],#8
    STCL            p1, c3, [R0],#8
    STCL            p1, c4, [R0],#8
    STCL            p1, c5, [R0],#8
    STCL            p1, c6, [R0],#8
    STCL            p1, c7, [R0],#8
    STCL            p1, c8, [R0],#8
    STCL            p1, c9, [R0],#8
    STCL            p1, c10, [R0],#8
    STCL            p1, c11, [R0],#8
    STCL            p1, c12, [R0],#8
    STCL            p1, c13, [R0],#8
    STCL            p1, c14, [R0],#8
    STCL            p1, c15, [R0],#8
  }
}

//----- (00001658) --------------------------------------------------------
void sub_1658() {
  __asm
  {
    STC2            p1, c8, [R0],#4
    STC2            p1, c9, [R0],#4
    STC2            p1, c10, [R0],#4
    STC2            p1, c11, [R0],#4
  }
}

//----- (0000166C) --------------------------------------------------------
int __fastcall sub_166C(int a1, const void *a2) {
  *(_DWORD *)a1 = &off_4E0C;
  *(_DWORD *)(a1 + 4) = &unk_5004;
  *(_BYTE *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  qmemcpy((void *)(a1 + 8), a2, 0x40u);
  memset((void *)(a1 + 80), 0, 0x1C2u);
  sub_1B84((int *)a1, 0);
  return 0;
}
// 4E0C: using guessed type void *;

//----- (000016B0) --------------------------------------------------------
int __fastcall sub_16B0(int a1, int a2, _DWORD *a3) {
  if ((*(int(__fastcall **)(int))(*(_DWORD *)a1 + 8))(a1) != 1)
    return -6542;
  *a3 = (*(int(__fastcall **)(int, int))(*(_DWORD *)a1 + 12))(a1, a2);
  return 0;
}

//----- (000016DE) --------------------------------------------------------
int __fastcall sub_16DE(int a1, int a2, int a3) {
  int v6; // r5

  if ((*(int(__fastcall **)(int))(*(_DWORD *)a1 + 8))(a1) != 1)
    return -6542;
  (*(void(__fastcall **)(int, int, int))(*(_DWORD *)a1 + 16))(a1, a2, a3);
  if (a2 != -1)
    return 0;
  v6 = 0;
  (*(void(__fastcall **)(int, _DWORD))(*(_DWORD *)a1 + 52))(a1, 0);
  return v6;
}

//----- (00001722) --------------------------------------------------------
int __fastcall sub_1722(int a1, int a2, _QWORD *a3) {
  if ((*(int(__fastcall **)(int))(*(_DWORD *)a1 + 20))(a1) != 1)
    return -6542;
  *a3 = ((__int64(__fastcall *)(int, int)) *
         (_DWORD *)(*(_DWORD *)a1 + 24))(a1, a2);
  return 0;
}

//----- (00001752) --------------------------------------------------------
int __fastcall sub_1752(int a1, int a2, int a3, int a4) {
  if ((*(int(__fastcall **)(int))(*(_DWORD *)a1 + 20))(a1) != 1)
    return -6542;
  (*(void(__fastcall **)(int, int, int, int))(*(_DWORD *)a1 + 28))(a1, a2, a3,
                                                                   a4);
  return 0;
}

//----- (0000178A) --------------------------------------------------------
int __fastcall sub_178A(int a1) {
  return (*(int(__fastcall **)(int))(*(_DWORD *)a1 + 32))(a1);
}

//----- (00001790) --------------------------------------------------------
int __fastcall sub_1790(int a1, int a2) {
  int result; // r0

  (*(void(__fastcall **)(int, int))(*(_DWORD *)a1 + 36))(a1, a2);
  result = 0;
  if (!*(_DWORD *)(a2 + 4))
    return -6549;
  return result;
}

//----- (000017AE) --------------------------------------------------------
int __fastcall sub_17AE(int a1) {
  (*(void(__fastcall **)(int))(*(_DWORD *)a1 + 40))(a1);
  return -6540;
}

//----- (000017C0) --------------------------------------------------------
int __fastcall sub_17C0(int a1) {
  return (*(int(__fastcall **)(int))(*(_DWORD *)a1 + 60))(a1);
}

//----- (000017C6) --------------------------------------------------------
bool __fastcall sub_17C6(int a1, int a2) {
  return (a2 & 0xFFFFFFFC) == 192 || (unsigned int)(a2 - 16) > 0xFFFFFFED;
}

//----- (000017E8) --------------------------------------------------------
int __fastcall sub_17E8(int a1, int a2) {
  int v4; // r0

  if (a2 > 12) {
    if (a2 != 15) {
      if (a2 == 14) {
        v4 = a1 + 64;
        return *(_DWORD *)v4;
      }
      if (a2 != 13)
        goto LABEL_11;
    LABEL_9:
      v4 = a1 + 60;
      return *(_DWORD *)v4;
    }
    goto LABEL_8;
  }
  if (a2 == -2)
    goto LABEL_9;
  if (a2 == -1) {
  LABEL_8:
    v4 = a1 + 68;
    return *(_DWORD *)v4;
  }
LABEL_11:
  if ((unsigned int)a2 > 0xC) {
    if ((a2 & 0xFFFFFFFC) != 192)
      sub_1C04("uint32_t libunwind::Registers_arm::getRegister(int)",
               "external/libunwind_llvm/src/Registers.hpp", 1452,
               "unsupported arm register");
    if (!*(_BYTE *)(a1 + 76)) {
      *(_BYTE *)(a1 + 76) = 1;
      sub_1658();
    }
    v4 = a1 + 4 * a2 - 296;
  } else {
    v4 = a1 + 4 * a2 + 8;
  }
  return *(_DWORD *)v4;
}

//----- (00001874) --------------------------------------------------------
int __fastcall sub_1874(int result, int a2, int a3) {
  int v5; // r5

  v5 = result;
  if (a2 > 12) {
    if (a2 != 15) {
      if (a2 == 14) {
        *(_DWORD *)(result + 64) = a3;
        return result;
      }
      if (a2 != 13)
        goto LABEL_11;
    LABEL_10:
      *(_DWORD *)(result + 60) = a3;
      return result;
    }
    goto LABEL_9;
  }
  if (a2 == -2)
    goto LABEL_10;
  if (a2 == -1) {
  LABEL_9:
    *(_DWORD *)(result + 68) = a3;
    return result;
  }
LABEL_11:
  if ((unsigned int)a2 > 0xC) {
    if ((a2 & 0xFFFFFFFC) != 192)
      sub_1C04("void libunwind::Registers_arm::setRegister(int, uint32_t)",
               "external/libunwind_llvm/src/Registers.hpp", 1471,
               "unsupported arm register");
    if (!*(_BYTE *)(result + 76)) {
      *(_BYTE *)(result + 76) = 1;
      sub_1658();
    }
    result = v5 + 4 * a2;
    *(_DWORD *)(result - 296) = a3;
  } else {
    result += 4 * a2;
    *(_DWORD *)(result + 8) = a3;
  }
  return result;
}

//----- (00001900) --------------------------------------------------------
bool __fastcall sub_1900(int a1, int a2) {
  return (a2 & 0xFFFFFFF0) == 112 || (a2 & 0xFFFFFFE0) == 256;
}

//----- (00001920) --------------------------------------------------------
__int64 __fastcall sub_1920(int a1, int a2) {
  unsigned int v4; // r0
  _QWORD *v5;      // r0
  int v6;          // r0

  v4 = a2 & 0xFFFFFFF0;
  if ((a2 & 0xFFFFFFF0) == 112) {
    if (!*(_BYTE *)(a1 + 75)) {
      *(_BYTE *)(a1 + 75) = 1;
      sub_1614();
    }
    v6 = a1 + 8 * a2 - 552;
  } else if (v4 == 272) {
    if (!*(_BYTE *)(a1 + 74)) {
      *(_BYTE *)(a1 + 74) = 1;
      sub_160C((_QWORD *)(a1 + 216));
    }
    v6 = a1 + 8 * a2 - 1960;
  } else {
    if (v4 != 256)
      sub_1C04("unw_fpreg_t libunwind::Registers_arm::getFloatRegister(int)",
               "external/libunwind_llvm/src/Registers.hpp", 1673,
               "Unknown ARM float register");
    if (!*(_BYTE *)(a1 + 73)) {
      *(_BYTE *)(a1 + 73) = 1;
      v5 = (_QWORD *)(a1 + 80);
      if (*(_BYTE *)(a1 + 72))
        sub_1604(v5);
      else
        sub_15FC(v5);
    }
    v6 = a1 + 8 * a2 - 1968;
  }
  return *(_QWORD *)v6;
}

//----- (000019C4) --------------------------------------------------------
int __fastcall sub_19C4(int a1, int a2, int a3, int a4) {
  unsigned int v6; // r0
  _QWORD *v9;      // r0
  int result;      // r0
  int v11;         // r1

  v6 = a2 & 0xFFFFFFF0;
  if ((a2 & 0xFFFFFFF0) == 112) {
    if (!*(_BYTE *)(a1 + 75)) {
      *(_BYTE *)(a1 + 75) = 1;
      sub_1614();
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 548) = a4;
    LOWORD(v11) = -552;
  } else if (v6 == 272) {
    if (!*(_BYTE *)(a1 + 74)) {
      *(_BYTE *)(a1 + 74) = 1;
      sub_160C((_QWORD *)(a1 + 216));
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 1956) = a4;
    LOWORD(v11) = -1960;
  } else {
    if (v6 != 256)
      sub_1C04(
          "void libunwind::Registers_arm::setFloatRegister(int, unw_fpreg_t)",
          "external/libunwind_llvm/src/Registers.hpp", 1700,
          "Unknown ARM float register");
    if (!*(_BYTE *)(a1 + 73)) {
      *(_BYTE *)(a1 + 73) = 1;
      v9 = (_QWORD *)(a1 + 80);
      if (*(_BYTE *)(a1 + 72))
        sub_1604(v9);
      else
        sub_15FC(v9);
    }
    result = a1 + 8 * a2;
    *(_DWORD *)(result - 1964) = a4;
    LOWORD(v11) = -1968;
  }
  HIWORD(v11) = -1;
  *(_DWORD *)(result + v11) = a3;
  return result;
}

//----- (00001A90) --------------------------------------------------------
bool __fastcall sub_1A90(_DWORD *a1) {
  _BOOL4 result; // r0
  __int64 v3;    // kr00_8
  int v4;        // r0

  if (*((_BYTE *)a1 + 528))
    return 0;
  result = sub_1C30((int)a1);
  if (!result)
    return result;
  (*(void(__fastcall **)(_DWORD *, int))(*a1 + 52))(a1, 1);
  if (*((_BYTE *)a1 + 528))
    return 0;
  if (a1[126]) {
    v3 = *(_QWORD *)(*a1 + 12);
    v4 = ((int(__fastcall *)(_DWORD *, int))v3)(a1, -2);
    ((void(__fastcall *)(_DWORD *, int, int))HIDWORD(v3))(a1, -2, a1[126] + v4);
  }
  return 1;
}

//----- (00001AE0) --------------------------------------------------------
_DWORD *__fastcall sub_1AE0(int a1, _DWORD *a2) {
  int *v2;        // r0
  _DWORD *result; // r0
  int v4;         // r2
  int v5;         // r3
  int v6;         // r4
  int v7;         // r12
  int v8;         // lr
  _DWORD *v9;     // r1
  int v10;        // r3
  int v11;        // r4
  int v12;        // r12
  int v13;        // lr

  v2 = (int *)(a1 + 488);
  v4 = *v2;
  v5 = v2[1];
  v6 = v2[2];
  v7 = v2[3];
  v8 = v2[4];
  result = v2 + 5;
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
  a2[4] = v8;
  v9 = a2 + 5;
  v10 = result[1];
  v11 = result[2];
  v12 = result[3];
  v13 = result[4];
  *v9 = *result;
  v9[1] = v10;
  v9[2] = v11;
  v9[3] = v12;
  v9[4] = v13;
  return result;
}

//----- (00001AF8) --------------------------------------------------------
int __fastcall sub_1AF8(int a1) {
  int v1; // r4

  v1 = a1 + 8;
  sub_1C84(a1 + 8);
  return sub_2390(v1);
}

//----- (00001B0E) --------------------------------------------------------
int __fastcall sub_1B0E(int a1) { return *(unsigned __int8 *)(a1 + 529); }

//----- (00001B14) --------------------------------------------------------
int __fastcall sub_1B14(int a1, int a2, int a3, _DWORD *a4) {
  int v7;          // r7
  char v9[8];      // [sp+8h] [bp-28h] BYREF
  const char *v10; // [sp+10h] [bp-20h]
  int v11;         // [sp+14h] [bp-1Ch]

  v7 = (*(int(__fastcall **)(int, int))(*(_DWORD *)a1 + 12))(a1, -1);
  if (!dladdr(v7, v9) || !v10)
    return 0;
  _snprintf_chk(a2, a3, 0, -1, "%s", v10);
  *a4 = v7 - v11;
  return 1;
}
// 92C: using guessed type int __fastcall dladdr(_DWORD, _DWORD);
// 938: using guessed type int _snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD,
// const char *, ...); 1B14: using guessed type char var_28[8];

//----- (00001B84) --------------------------------------------------------
int __fastcall sub_1B84(int *a1, int a2) {
  int v4;    // r5
  int v6[2]; // [sp+0h] [bp-20h] BYREF
  int v7[6]; // [sp+8h] [bp-18h] BYREF

  v4 = (*(int(__fastcall **)(int *, int))(*a1 + 12))(a1, -1) & 0xFFFFFFFE;
  v7[0] = 0;
  if (a2)
    --v4;
  v6[0] = _gnu_Unwind_Find_exidx(v4, v7);
  v6[1] = v7[0];
  if (!v6[0] || !v7[0] || !sub_1CDC(a1, v4, v6))
    *((_BYTE *)a1 + 528) = 1;
  return _stack_chk_guard - v7[1];
}
// 944: using guessed type int __fastcall _gnu_Unwind_Find_exidx(_DWORD,
// _DWORD);

//----- (00001BFA) --------------------------------------------------------
int __fastcall sub_1BFA(int result) {
  *(_BYTE *)(result + 72) = 1;
  return result;
}

//----- (00001C04) --------------------------------------------------------
void __fastcall __noreturn sub_1C04(const char *a1, const char *a2, int a3,
                                    const char *a4) {
  fprintf(stderr, "libunwind: %s %s:%d - %s\n", a1, a2, a3, a4);
  abort();
}

//----- (00001C30) --------------------------------------------------------
bool __fastcall sub_1C30(int a1) {
  unsigned int *v2; // r0
  unsigned int v4;  // [sp+4h] [bp-1Ch] BYREF
  unsigned int v5;  // [sp+8h] [bp-18h] BYREF

  v4 = 0;
  v5 = 0;
  v2 = sub_D60(*(unsigned int **)(a1 + 520), (int *)&v4, (int *)&v5);
  return sub_DB4(a1, (int)v2, v4, v5) == 8;
}

//----- (00001C84) --------------------------------------------------------
_DWORD *__fastcall sub_1C84(int a1) {
  int v2;         // r0
  _DWORD *result; // r0

  if (*(_BYTE *)(a1 + 65)) {
    if (*(_BYTE *)(a1 + 64))
      sub_2328();
    else
      sub_2320();
  }
  if ((unsigned __int8)*(_WORD *)(a1 + 66)) {
    sub_2330();
    v2 = *(unsigned __int8 *)(a1 + 67);
  } else {
    v2 = HIBYTE(*(unsigned __int16 *)(a1 + 66));
  }
  if (v2)
    sub_2338((int *)(a1 + 336));
  result = (_DWORD *)*(unsigned __int8 *)(a1 + 68);
  if (*(_BYTE *)(a1 + 68))
    return sub_23A0((int *)(a1 + 464));
  return result;
}

//----- (00001CDC) --------------------------------------------------------
int __fastcall sub_1CDC(int *a1, int a2, _DWORD *a3) {
  int v4;           // r5
  int v5;           // r6
  char *v6;         // r5
  int *v7;          // r0
  int v8;           // r3
  int v9;           // r7
  int *v10;         // r6
  char *v11;        // lr
  int v12;          // r12
  int v13;          // r9
  int v14;          // r6
  int v15;          // r6
  unsigned int v16; // r2
  int v18[3];       // [sp+14h] [bp-34h] BYREF
  int v19;          // [sp+20h] [bp-28h] BYREF

  v4 = 0;
  v19 = a2;
  v5 = a3[1];
  sub_1E80(v18, 0, a1[1], a3, v5, a1[1], (int)a3, &v19);
  if (!v18[0] || v18[0] == v5)
    return v4;
  v6 = (char *)(*(_DWORD *)v18[2] + 8 * v18[0]);
  v7 = (int *)(v6 - 4);
  v8 = *(_DWORD *)v6;
  if (v6 == &byte_4)
    return 0;
  v9 = *v7;
  if (*v7 == 1)
    return 0;
  if (v9 < 0) {
    v12 = 1;
    goto LABEL_11;
  }
  v10 = (int *)((char *)v7 + (v9 | (2 * v9) & 0x80000000));
  v9 = *v10;
  if (*v10 <= -1) {
    v12 = 0;
    v7 = v10;
  LABEL_11:
    v14 = HIBYTE(v9) & 0xF;
    if (v14 == 2) {
      v11 = byte_1341;
      v15 = 1;
    } else {
      if (v14 != 1) {
        if (v14)
          sub_1C04(
              "bool libunwind::UnwindCursor<libunwind::LocalAddressSpace, "
              "libunwind::Registers_arm>::getInfoFromEHABISectio"
              "n(pint_t, const libunwind::UnwindInfoSections &) [A = "
              "libunwind::LocalAddressSpace, R = libunwind::Registers_arm]",
              "external/libunwind_llvm/src/UnwindCursor.hpp", 776,
              "unknown personality routine");
        v13 = (int)(v7 + 1);
        if (v12)
          v13 = 0;
        v11 = byte_12D5;
        goto LABEL_17;
      }
      v11 = byte_1339;
      v15 = 0;
    }
    if (((BYTE2(v9) != 0) & (unsigned __int8)v12) == 1)
      sub_1C04(
          "bool libunwind::UnwindCursor<libunwind::LocalAddressSpace, "
          "libunwind::Registers_arm>::getInfoFromEHABISection(pi"
          "nt_t, const libunwind::UnwindInfoSections &) [A = "
          "libunwind::LocalAddressSpace, R = libunwind::Registers_arm]",
          "external/libunwind_llvm/src/UnwindCursor.hpp", 783,
          "index inlined table detected but pr function requires extra words");
    v13 = (int)&v7[BYTE2(v9) + 1];
    goto LABEL_22;
  }
  v11 = (char *)v10 + ((2 * v9) & 0x80000000 | v9);
  v12 = 0;
  v13 = (int)&v10[HIBYTE(v10[1]) + 2];
  v7 = v10;
LABEL_17:
  v15 = 0;
LABEL_22:
  v16 = (2 * *((_DWORD *)v6 - 2)) & 0x80000000 | *((_DWORD *)v6 - 2);
  a1[130] = (int)v7;
  a1[122] = (int)&v6[v16 - 8];
  a1[123] = (int)&v6[v8 | (2 * v8) & 0x80000000];
  a1[124] = v13;
  a1[125] = (int)v11;
  if (v15)
    v15 = 2;
  if (v12)
    v15 = 1;
  v4 = 1;
  a1[127] = v15;
  return v4;
}
// 4: using guessed type char;

//----- (00001E80) --------------------------------------------------------
_DWORD *__fastcall sub_1E80(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5,
                            int a6, int a7, _DWORD *a8) {
  unsigned int v8; // r4
  unsigned int v9; // r5
  int v10;         // r6

  v8 = a5 - a2;
  while (1) {
    v9 = v8;
    if (!v8)
      break;
    v10 = a2 + (v8 >> 1);
    v8 >>= 1;
    if (*a8 >= *a4 + 8 * v10 +
                   ((2 * *(_DWORD *)(*a4 + 8 * v10)) & 0x80000000 |
                    *(_DWORD *)(*a4 + 8 * v10))) {
      v8 = v9 - 1 - v8;
      a2 = v10 + 1;
    }
  }
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  return a1 + 3;
}

//----- (0000230C) --------------------------------------------------------
int __fastcall sub_230C(int a1) {
  return (*(int(__fastcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(a1 + 60))(
      *(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8),
      *(_DWORD *)(a1 + 12));
}

//----- (00002320) --------------------------------------------------------
void sub_2320() { ; }

//----- (00002328) --------------------------------------------------------
void sub_2328() { ; }

//----- (00002330) --------------------------------------------------------
void sub_2330() { ; }

//----- (00002338) --------------------------------------------------------
_DWORD *__fastcall sub_2338(int *a1) {
  int *v5;        // r0
  _DWORD *result; // r0

  _T1 = *a1;
  v5 = a1 + 2;
  __asm { LDCL            p1, c0, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c1, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c2, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c3, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c4, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c5, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c6, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c7, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c8, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c9, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c10, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c11, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c12, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c13, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c14, [R0],#8 }
  _T1 = *v5;
  result = v5 + 2;
  __asm { LDCL            p1, c15, [R0],#8 }
  return result;
}

//----- (0000237C) --------------------------------------------------------
_DWORD *__fastcall sub_237C(int *a1) {
  int *v5;        // r0
  _DWORD *result; // r0

  _T1 = *a1;
  v5 = a1 + 1;
  __asm { LDC2            p1, c8, [R0],#4 }
  _T1 = *v5++;
  __asm { LDC2            p1, c9, [R0],#4 }
  _T1 = *v5++;
  __asm { LDC2            p1, c10, [R0],#4 }
  _T1 = *v5;
  result = v5 + 1;
  __asm { LDC2            p1, c11, [R0],#4 }
  return result;
}

//----- (00002390) --------------------------------------------------------
// attributes: thunk
int __fastcall sub_2390(int a1) { return sub_230C(a1); }

//----- (000023A0) --------------------------------------------------------
// attributes: thunk
_DWORD *__fastcall sub_23A0(int *a1) { return sub_237C(a1); }

// nfuncs=102 queued=58 decompiled=58 lumina nreq=0 worse=0 better=0
// ALL OK, 58 function(s) have been successfully decompiled
